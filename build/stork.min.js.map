{"version":3,"sources":["header.js","functions.js","Stork.js","Promise.js","FastMap.js","extending.js","chrome-storage-local.js","local-storage.js","memory.js","webkit-sqlite.js","window-name.js","footer.js"],"names":["global","undefined","isFunc","x","constructor","call","apply","isObject","isNumber","isNaN","undef","def","coalesce","a","b","c","d","copy","from","to","prop","S4","Math","random","toString","substring","uuid","compareAdapters","priority","getAdapter","adapterName","chosen","i","Stork","adapters","length","adapt","name","definition","valid","sort","options","success","failure","this","key","lazy","cache","FastMap","pending","initialized","loaded","adapter","plugins","initializing","init","Promise","context","root","next","nextFromSuccess","state","PENDING","successes","failures","errors","args","$queue","map","reset","putMap","toJson","JSON","stringify","fromJson","parse","prototype","decode","encode","handlePending","method","promise","handled","push","arguments","Array","slice","finishInitialization","$success","newPromise","$bindTo","finishReload","$pending","values","okeys","reload","then","callback","getMany","keys","get","gotten","addValue","value","onFailure","e","$failure","rawKey","has","_get","destroy","_destroy","save","record","keyName","onSuccess","error","put","batch","records","saves","onSaved","setFailure","rawValue","_put","remove","_remove","removeMany","removed","each","stork","iterate","size","_size","all","returnAll","FAILURE","SUCCESS","CHAINED","$handleSuccesses","$handleFailures","replacementArguments","succs","s","result","$handleNext","returned","fails","errorArgument","indices","originalKey","index","removeAt","lastValue","pop","lastKey","lastOkey","indexOf","hasOverlap","plugin","isError","chrome","runtime","lastError","store","window","storage","local","prefix","temp","set","_finishInitialization","items","removeByKeys","obj","previousValue","localStorage","setItem","removeItem","getItem","streplace","str","arr","replace","match","parseInt","DATABASE_NAME","SQL_CREATE","SQL_SELECT","SQL_SELECT_ALL","SQL_INSERT","SQL_DELETE","SQL_COUNT","SQL_DESTROY","SQL_DELETE_MANY","openDatabase","databaseName","database","databaseSize","databaseVersion","version","tx","onTransactionForCreate","executeSql","onCreate","results","db","transaction","onTransactionForSelect","onResults","rows","id","readTransaction","onTransaction","onResult","first","successful","converted","rawKeys","binder","query","join","onCount","count","loadData","top","saveData","data"],"mappings":"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","file":"stork.min.js","sourcesContent":["'use strict';\n\n(function(global, undefined) \n{\n\n\n","var toJson = JSON.stringify;\n\nvar fromJson = JSON.parse;\n\nfunction isFunc(x)\n{\n  return !!(x && x.constructor && x.call && x.apply);\n}\n\nfunction isObject(x)\n{\n  return typeof x === 'object' && x !== null;\n}\n\nfunction isNumber(x)\n{\n  return typeof x === 'number' && !isNaN(x);\n}\n\nfunction undef(x)\n{\n  return typeof x === 'undefined';\n}\n\nfunction def(x)\n{\n  return typeof x !== 'undefined';\n}\n\nfunction coalesce(a, b, c, d)\n{\n  if (def(a)) return a;\n  if (def(b)) return b;\n  if (def(c)) return c;\n  return d;\n}\n\nfunction noop()\n{\n}\n\nfunction fn(func)\n{\n  return isFunc( func ) ? func : noop;\n}\n\nfunction fncoalesce(a, b)\n{\n  return isFunc( a ) ? a : (isFunc(b) ? b : noop);\n}\n\nfunction copy(from, to)\n{\n  for (var prop in from)\n  {\n    to[ prop ] = from[ prop ];\n  }\n}\n\nfunction S4() \n{\n  return (((1+Math.random())*0x10000)|0).toString(16).substring(1);\n}\n\nfunction uuid() \n{\n    return (S4()+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+S4()+S4());\n}\n\nfunction compareAdapters(a, b)\n{\n  var d = b.priority - a.priority;\n\n  return d === 0 ? 0 : (d < 0 ? -1 : 1);\n}\n\nfunction getAdapter(adapterName)\n{\n  if ( !getAdapter.chosen ) \n  {\n    if ( adapterName )\n    {\n      for (var i = 0; i < Stork.adapters.length; i++) \n      {\n        var adapt = Stork.adapters[i];\n\n        if ( adapt.name === adapterName && adapt.definition.valid() )\n        {\n          return adapt;\n        }\n      }\n    }\n\n    Stork.adapters.sort( compareAdapters );\n\n    for (var i = 0; i < Stork.adapters.length; i++) \n    {\n      var adapt = Stork.adapters[i];\n\n      if ( adapt.definition.valid() )\n      {\n        return getAdapter.chosen = adapt;\n      }\n    }\n  }\n\n  return getAdapter.chosen;\n}","\n\n/**\n * Creates a Stork instance.\n *\n * ```javascript\n * new Stork(); // global key-values/records\n * new Stork({name: 'todos'}); // grouped key-values/records\n * new Stork({name: 'rooms', key: 'ID'}); // records have 'ID' property which is used as key for saving records\n * new Stork({name: 'you are', lazy: true}); // records aren't all loaded on start, they are loaded as needed\n * new Stork({name: 'users', database: 'myapp', size: 65536}); // some storage engines support a custom database name and a desired size for the database\n *\n * new Stork(options, function(stork) {\n *   // stork = initialized stork instance\n * });\n * ```\n *\n * @constructor\n * @class\n * @param {Object} [options]\n *        An object of options, see the following properties for more details:\n *        {@link Stork#key}, {@link Stork#name}, {@link Stork#lazy}.\n * @param {Stork~initSuccess} [success]\n *        The function to invoke when the instance successfully initializes.\n * @param {Stork~initFailure} [failure]\n *        The function to invoke if this instance failes to initialize.\n */\nfunction Stork(options, success, failure)\n{\n  /**\n   * The options passed to the constructor and subsequently to the \n   * {@link Stork#init} function.\n   * \n   * @type {Object}\n   * @default  {}\n   */\n  this.options = options = (options || {});\n\n  /**\n   * The name of the property to use as the key for the \n   * {@link Stork#save} and {@link Stork#batch} functions. This should \n   * be specified in the `options` object.\n   * \n   * @type {String}\n   * @default 'id'\n   */\n  this.key = coalesce( options.key, 'id' );\n\n  /**\n   * The name used to group the key-value pairs. This is essentially\n   * a table name. This should be specified in the `options` object.\n   *           \n   * @type {String}\n   * @default ''\n   */\n  this.name = coalesce( options.name, '' );\n\n  /**\n   * If true, key-value pairs will be lazily loaded instead of loaded\n   * all at once on initialization. This should be specified in the \n   * `options` object.\n   *           \n   * @type {Boolean}\n   * @default false\n   */\n  this.lazy = coalesce( options.lazy, false );\n\n  /**\n   * The cache of key-value pairs currently loaded. If \n   * {@link Stork#loaded} is true then all key-value pairs exist in\n   * the cache.\n   *           \n   * @type {FastMap}\n   */\n  this.cache = new FastMap();\n\n  /**\n   * An array of functions called by the user before this instances\n   * was finished initializing. Once this instance successfully finishes \n   * initialization all pending functions are invoked in the order\n   * in which they were originally made and this property is set to\n   * `null`.\n   *           \n   * @type {Object[]}\n   */\n  this.pending = [];\n\n  /**\n   * True if this instance has successfully initialized, otherwise\n   * false if it failed to initialize or has not finished initializing.\n   *           \n   * @type {Boolean}\n   */\n  this.initialized = false;\n\n  /**\n   * True if the entire instance has been loaded into the \n   * {@link Stork#cache}, otherwise false. If lazy is specifed as true\n   * loaded will be false until any of the following methods are\n   * invoked: {@link Stork#each}, {@link Stork#all}, or\n   * {@link Stork#reload}.\n   *           \n   * @type {Boolean}\n   */\n  this.loaded = false;\n\n  /**\n   * The adapter `Object` with `String` name, `Number` priority, and\n   * `Object` definition properties. The adapter can be chosen based\n   * on the `options.adapter` and falls back to the next supported\n   * adapter based on priority.\n   *           \n   * @type {Object}\n   */\n  this.adapter = getAdapter( options.adapter );\n\n  // Copy the chosen adapter methods into this instance.\n  copy( this.adapter.definition, this );\n  \n  // Call each plugin on this instance before initialization starts.\n  for (var i = 0; i < Stork.plugins.length; i++)\n  {\n    Stork.plugins[ i ]( this );\n  }\n\n  // Start initializaing this instance.\n  this.initializing = this.init( this.options, success, failure );\n}\n\nStork.prototype = \n{\n\n  /**\n   * Decodes a key from a string.\n   *\n   * @method decode\n   * @param {String} rawKey\n   *        The string to decode into a key.\n   * @return {Any}\n   */\n  decode: fromJson,\n\n  /**\n   * Encodes a key into a string.\n   *\n   * @method encode\n   * @param {Any} key\n   *        The key to encode to a string.\n   * @return {String}\n   */\n  encode: toJson,\n  \n  /**\n   * Returns true if this Stork is not ready for storage calls and queues\n   * the method and arguments to be called after this Stork is initialized.\n   *\n   * @private\n   * @param  {function} method \n   *         The reference to the calling function\n   * @param  {Arguments} args \n   *         The arguments of the calling function\n   * @param  {Stork.Promise} promise \n   *         The promise to notify when the function is finally called.\n   * @return {Boolean} \n   *         Returns true if the calling function should return this\n   *         immediately because the implementation isn't initialized yet.\n   */\n  handlePending: function(method, args, promise) \n  {\n    var handled = !this.initialized;\n\n    if (handled) \n    {\n      this.pending.push(\n      {\n        method: method,\n        arguments: Array.prototype.slice.call( args ),\n        promise: promise\n\n      });\n    }\n\n    return handled;\n  },\n\n  /**\n   * Marks the Stork as initialized and executes any pending functions.\n   *\n   * @private\n   * @param  {Stork.Promise} promise\n   *         The promise for {@link Stork#init} or {@link Stork#reload}.\n   * @return {Stork} \n   *         A reference to this.\n   */\n  finishInitialization: function(promise, args) \n  {\n    if (!this.initialized) \n    {\n      this.initialized = true;\n\n      promise.$success( args );\n\n      for (var i = 0; i < this.pending.length; i++) \n      {\n        var pending = this.pending[ i ];\n        var newPromise = pending.method.apply( this, pending.arguments );\n\n        if ( pending.promise )\n        {\n          pending.promise.$bindTo( newPromise );\n        }\n      }\n\n      this.pending = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * Finishes the reload function passing the now cached values and keys\n   * to the success callbacks.\n   *\n   * @private\n   * @param  {Stock.Promise} promise\n   *         The promise for the {@link Stork#reload} invocation.\n   */\n  finishReload: function(promise)\n  {\n    if ( promise.$pending() )\n    {\n      var cache = this.cache;\n\n      if ( this.initialized )\n      {\n        promise.$success( [cache.values, cache.okeys] );\n      }\n      else\n      {\n        this.finishInitialization( promise, [cache.values, cache.okeys] );\n      }\n    }\n  },\n\n  /**\n   * Determines whether this Stork implementation is available.\n   * \n   * @return {Boolean} True if this Stork is usable, otherwise false.\n   */\n  valid: function() \n  {\n    throw 'Stork.valid is not implemented';\n  },\n  \n  /**\n   * The format of success callback for {@link Stork#init}.\n   * \n   * @callback Stork~initSuccess\n   * @param {Stork} stork\n   *        The reference to this Stork instance.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#init}.\n   * \n   * @callback Stork~initFailure\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Initializes this Stork instance. If `options.lazy` is passed in as true,\n   * key-value pairs will not be loaded here, otherwise all key-value\n   * pairs will be loaded. This function is automatically called at the end\n   * of the Stork constructor with the options passed to the constructor.\n   * \n   * @param  {Object} options\n   *         The initialization options.\n   * @param  {Stork~initSuccess} [success]\n   *         The function to invoke when the Stork instance successfully \n   *         initializes and is usable.\n   * @param  {Stork~initFailure} [failure]\n   *         The function to invoke if there's a problem initializing.\n   * @return {Stork.Promise}\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  init: function(options, success, failure) \n  {\n    throw 'Stork.init is not implemented';\n  },\n  \n  /**\n   * The format of success callback for {@link Stork#reload}.\n   * \n   * @callback Stork~reloadSuccess\n   * @param {Array} values\n   *        An array of all values loaded. This should not be modified.\n   * @param {Array} keys\n   *        An array of all keys loaded. This should not be modified.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#reload}.\n   * \n   * @callback Stork~reloadFailure\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Loads all key-value pairs into the cache which will increase performance \n   * for fetching operations ({@link Stork#get}, {@link Stork#getMany}, \n   * {@link Stork#each}, {@link Stork#all}).\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(values, keys) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(error) {\n   *   // uh oh!\n   * };\n   * db.reload(); // I don't care about whether it succeeds or fails\n   * db.reload( onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.reload().then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   * \n   * @param  {Stork~reloadSuccess} [success]\n   *         The function to invoke when all key-value pairs are loaded.\n   * @param  {Stork~reloadFailure} [failure]\n   *         The function to invoke if there was a problem loading all key-value\n   *         pairs.\n   * @return {Stork.Promise}\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  reload: function(success, failure)\n  {\n    throw 'Stork.reload is not implemented';\n  },\n\n  /**\n   * A helper method for creating a consistent look when chaining promised\n   * functions.\n   *\n   * *Usage*\n   * ```javascript\n   * db.then(function() { // <--\n   *     // this === db, how big is it?\n   *     return this.size();\n   *   })\n   *   .then(function(size) {\n   *     // size has been determined, destroy!\n   *     return this.destroy();\n   *   })\n   *   .then(function(){\n   *     // You sunk my battleship! (destroyed db)\n   *   })\n   * ;\n   * ```\n   * \n   * @param  {function} callback\n   *         The callback to invoke with this Stork instance as `this`.\n   * @return {Stork.Promise}\n   *         The callback should return a Promise to chain additional functions.\n   */\n  then: function(callback)\n  {\n    return callback.apply( this );\n  },\n\n  /**\n   * The format of success callback for {@link Stork#getMany}.\n   * \n   * @callback Stork~getManySuccess\n   * @param {Array} values\n   *        The array of values associated to the given keys. If a key wasn't \n   *        found then the value in the array will be `undefined`.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#getMany}.\n   * \n   * @callback Stork~getManyFailure\n   * @param {Array} keys\n   *        The keys given that resulted in an error.\n   * @param {Any} error \n   *        The error that was thrown.\n   */\n\n  /**\n   * Gets an array of values given an array of keys and returns it to the\n   * callback. If the key doesn't exist then the corresponding value in the\n   * returned array will be `undefined`.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(values, keys) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(keys, error) {\n   *   // uh oh!\n   * };\n   * db.getMany( arrayOfKeys, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.getMany( arrayOfKeys ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   * \n   * @param  {Array} keys\n   *         The keys of the key-value pairs to get.\n   * @param  {Stork~getManySuccess} [success]\n   *         THe function to invoke with the values found.\n   * @param  {Stork~getManyFailure} [failure]\n   *         The function to invoke if there was a problem getting values.\n   * @return {Stork.Promise}\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  getMany: function(keys, success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.get, arguments, promise ) ) \n    {\n      return promise;\n    }\n\n    var gotten = 0;\n    var values = [];\n\n    var addValue = function(i)\n    {\n      return function(value)\n      {\n        values[ i ] = value;\n\n        if ( ++gotten === keys.length )\n        {\n          promise.$success( [values, keys] );\n        }\n      };\n    };\n    var onFailure = function(e)\n    {\n      promise.$failure( [keys, e] );\n    };\n\n    for (var i = 0; i < keys.length; i++)\n    {\n      this.get( keys[ i ], addValue( i ), onFailure );\n    }\n\n    return promise;\n  },\n\n  /**\n   * The format of success callback for {@link Stork#get}.\n   * \n   * @callback Stork~getSuccess\n   * @param {Any} value\n   *        The value associated to the given key or `undefined` if one was not\n   *        found.\n   * @param {Any} key\n   *        The key of the key-value pair that was successfully found.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#get}.\n   * \n   * @callback Stork~getFailure\n   * @param {Any} key\n   *        The key of the key-value pair that was unsuccessfully gotten.\n   * @param {Any} error \n   *        The error that was thrown.\n   */\n\n  /**\n   * Gets the value for the given key and returns it to the callback. If the\n   * key doesn't exist then `undefined` is given to the callback.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(value, key) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(key, error) {\n   *   // uh oh!\n   * };\n   * db.get( key, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.get( key ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   * \n   * @param  {Any} key\n   *         The key of the key-value pair to get.\n   * @param  {Stork~getSuccess} [success]\n   *         The function to invoke if a value is successfully found or not found.\n   * @param  {Stork~getFailure} [failure]\n   *         The function to invoke if there was a problem.\n   * @return {Stork.Promise}\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  get: function(key, success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.get, arguments, promise ) ) \n    {\n      return promise;\n    }\n\n    var rawKey;\n\n    try\n    {\n      rawKey = this.encode( key );\n    }\n    catch (e)\n    {\n      promise.$failure( [key, e] );\n    }\n\n    if ( promise.$pending() )\n    {\n      if ( this.cache.has( rawKey ) )\n      {\n        promise.$success( [this.cache.get( rawKey ), key] );\n      }\n      else if ( this.loaded )\n      {\n        promise.$success( [undefined, key] );\n      }\n      else\n      {\n        this._get( key, rawKey, promise );\n      }\n    }\n\n    return promise;\n  },\n\n  _get: function(key, rawKey, promise)\n  {\n    throw 'Stork._get is not implemented';\n  },\n\n  /**\n   * The format of success callback for {@link Stork#destroy}.\n   * \n   * @callback Stork~destroySuccess\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#destroy}.\n   * \n   * @callback Stork~destroyFailure\n   * @param {Any} error \n   *        The error that was thrown.\n   */\n\n  /**\n   * Removes all key-value pairs and invokes the callback.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function() {\n   *   // DESTROYED!\n   * };\n   * var onFailureFunc = function(error) {\n   *   // uh oh!\n   * };\n   * db.destroy(); // I don't care about whether it succeeds or fails\n   * db.destroy( onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.destroy().then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   * \n   * @param  {Stork~destroySuccess} [success]\n   *         The function invoked when all key-value pairs are removed.\n   * @param  {Stork~destroyFailure} [failure]\n   *         The function invoked if there was a problem removing all key-value\n   *         pairs.\n   * @return {Stork.Promise}\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  destroy: function(success, failure) \n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.destroy, arguments, promise ) ) \n    {\n      return promise;\n    }\n\n    this._destroy( promise );\n\n    return promise;\n  },\n\n  _destroy: function(promise)\n  {\n    throw 'Stork._destroy is not implemented';\n  },\n\n  /**\n   * The format of success callback for {@link Stork#save}.\n   * \n   * @callback Stork~saveSuccess\n   * @param {Object} record\n   *        The record that successfully saved.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#save}.\n   * \n   * @callback Stork~saveFailure\n   * @param {Object} record\n   *        The record that failed to save.\n   * @param {Any} error \n   *        The error that was thrown.\n   */\n\n  /**\n   * Saves an `Object` record and returns the saved record to the callback. The \n   * record is the value in the key-value pair and the key is pulled from the \n   * record based on the options passed into the {@link Stork#init} function. \n   * The property used as the key is `this.key` and by default is `id`. If a key \n   * isn't specified in a record then a UUID is used and placed in the object.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(record) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(record, error) {\n   *   // uh oh!\n   * };\n   * db.save( record ); // I don't care about whether it succeeds or fails\n   * db.save( record, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.save( record ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   * \n   * @param  {Object} record\n   *         The record to save.\n   * @param  {Stork~saveSuccess} [success]\n   *         The function to invoke when the record is successfully saved.\n   * @param  {Stork~saveFailure} [failure]\n   *         The function to invoke if the record fails to save.\n   * @return {Stork.Promise}\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  save: function(record, success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.save, arguments, promise ) ) \n    {\n      return promise;\n    }\n\n    var keyName = this.key;\n    var key = record[ keyName ];\n\n    if ( undef( key ) ) \n    {\n      key = record[ keyName ] = uuid();\n    }\n\n    var onSuccess = function(key, value)\n    {\n      promise.$success( [value] );\n    };\n    var onFailure = function(key, value, error)\n    {\n      promise.$failure( [value, error] );\n    };\n\n    this.put( key, record, onSuccess, onFailure );\n\n    return promise;\n  },\n\n  /**\n   * The format of success callback for {@link Stork#batch}.\n   * \n   * @callback Stork~batchSuccess\n   * @param {Array} records\n   *        The records successfully saved.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#batch}.\n   * \n   * @callback Stork~batchFailure\n   * @param {Array} records\n   *        The records unsuccessfully saved.\n   * @param {Number} recordsSaved\n   *        The number of records that successfully saved.\n   * @param {Any} error \n   *        The error that was thrown.\n   */\n\n  /**\n   * Saves an array of `Object` records and returns the records saved to the \n   * callback. The record is the value in the key-value pair and the key is \n   * pulled from the record based on the options passed into the \n   * {@link Stork#init} function. The property used as the key is `this.key` and\n   * by default is `id`. If a key isn't specified in a record then a UUID is \n   * used and placed in the object.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(records) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(records, recordsSaved, error) {\n   *   // uh oh!\n   * };\n   * db.batch( records ); // I don't care about whether it succeeds or fails\n   * db.batch( records, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.batch( records ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   * \n   * @param  {Array} records\n   *         The array of objects to save.\n   * @param  {Stork~batchSuccess} [success]\n   *         The function to invoke when all records are successfully saved.\n   * @param  {Stork~batchFailure} [failure]\n   *         THe function to invoke if any of the records failed to save.\n   * @return {Stork.Promise}\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  batch: function(records, success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.batch, arguments, promise ) ) \n    {\n      return promise;\n    }\n\n    var saves = 0;\n\n    var onSaved = function() \n    {\n      if ( ++saves === records.length ) \n      {\n        promise.$success( [records] );\n      }\n    }\n    var setFailure = function(e) \n    {\n      promise.$failure( [records, saves, e] );\n    };\n\n    for (var i = 0; i < records.length && !promise.state; i++)\n    {\n      this.save( records[ i ], onSaved, setFailure );\n    }\n\n    return promise;\n  },\n\n  /**\n   * The format of success callback for {@link Stork#put}.\n   * \n   * @callback Stork~putSuccess\n   * @param {Any} key\n   *        The key to add or update.\n   * @param {Any} value\n   *        The value to add or update.\n   * @param {Any} previousValue\n   *        The previous value for the key if it exists in the cache.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#put}.\n   * \n   * @callback Stork~putFailure\n   * @param {Any} key\n   *        The key that failed to be added or updated.\n   * @param {Any} value\n   *        The value that failed to be added or updated.\n   * @param {Any} error \n   *        The error that was thrown.\n   */\n\n  /**\n   * Adds or updates the value mapped by the given key and returns the key\n   * and value placed to the callback.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(key, value, previousValue) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(key, value, error) {\n   *   // uh oh!\n   * };\n   * db.put( key, value ); // I don't care about whether it succeeds or fails\n   * db.put( key, value, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.put( key, value ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   * \n   * @param  {Any} key\n   *         The key to add or update.\n   * @param  {Any} value\n   *         The value to add or update.\n   * @param  {Stork~putSuccess} [success]\n   *         The function to invoke when the key-value pair is successfully \n   *         added or updated.\n   * @param  {Stork~putFailure} [failure]\n   *         The function to invoke if there was a problem putting the key-value\n   *         pair.\n   * @return {Stork.Promise}\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  put: function(key, value, success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.put, arguments, promise ) ) \n    {\n      return promise;\n    }\n\n    var rawKey, rawValue;\n\n    try\n    {\n      rawKey = this.encode( key );\n      rawValue = toJson( value );   \n    }\n    catch (e)\n    {\n      promise.$failure( [key, value, e] );\n    }\n\n    if ( promise.$pending() )\n    {\n      this._put( key, value, rawKey, rawValue, promise );\n    }\n\n    return promise;\n  },\n\n  _put: function(key, value, rawKey, rawValue, promise)\n  {\n    throw 'Stork._put is not implemented';\n  },\n\n  /**\n   * The format of success callback for {@link Stork#remove}.\n   * \n   * @callback Stork~removeSuccess\n   * @param {Any} value\n   *        The value removed or `undefined` if the key didn't exist.\n   * @param {Any} key\n   *        The key of the key-value pair that was removed.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#remove}.\n   * \n   * @callback Stork~removeFailure\n   * @param {Any} key\n   *        The key of the key-value pair that failed to be removed.\n   * @param {Any} error \n   *        The error that was thrown.\n   */\n\n  /**\n   * Removes the key-value pair for the given key and returns the removed value\n   * to the callback if on existed.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(value, key) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(key, error) {\n   *   // uh oh!\n   * };\n   * db.remove( key ); // I don't care about whether it succeeds or fails\n   * db.remove( key, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.remove( key ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   * \n   * @param  {Any} key\n   * @param  {Stork~removeSuccess} [success]\n   *         The function to invoke then the key is removed or doesn't exist.\n   * @param  {Stork~removeFailure} [failure]\n   *         The function to invoke if there was a problem removing the key.\n   * @return {Stork.Promise}\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  remove: function(key, success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.remove, arguments, promise ) ) \n    {\n      return promise;\n    }\n\n    var rawKey;\n\n    try\n    {\n      rawKey = this.encode( key );\n    }\n    catch (e)\n    {\n      promise.$failure( [key, e] );\n    }\n\n    if ( promise.$pending() )\n    {\n      if ( this.loaded && !this.cache.has( rawKey ) )\n      {\n        promise.$success( [undefined, key] );\n      }\n      else\n      {\n        var value = this.cache.get( rawKey );\n\n        this._remove( key, rawKey, value, promise );      \n      }\n    }\n\n    return promise;\n  },\n\n  _remove: function(key, rawKey, value, promise)\n  {\n    throw 'Stork._remove is not implemented';\n  },\n\n  /**\n   * The format of success callback for {@link Stork#removeMany}.\n   * \n   * @callback Stork~removeManySuccess\n   * @param {Array} values\n   *        The values removed in the same order of the keys. If a key didn't\n   *        exist then the corresponding value in the array will be `undefined`.\n   * @param {Array} keys\n   *        The corresponding removed keys.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#removeMany}.\n   * \n   * @callback Stork~removeManyFailure\n   * @param {Array} values\n   *        The values removed in the same order of the given keys.\n   * @param {Number} removed\n   *        The number of records removed before the error occurred.\n   * @param {Any} error \n   *        The error that was thrown.\n   */\n\n  /**\n   * Removes multiple key-value pairs and returns the values removed to the \n   * given callback.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(values, keys) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(values, removed, error) {\n   *   // uh oh!\n   * };\n   * db.removeMany( keys ); // I don't care about whether it succeeds or fails\n   * db.removeMany( keys, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.removeMany( keys ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   * \n   * @param  {Array} keys\n   *         The array of keys to remove.\n   * @param  {Stork~removeManySuccess} [success]\n   *         The function to invoke once all matching key-value pairs are \n   *         removed, with the values removed.\n   * @param  {Stork~removeManyFailure} [failure]\n   *         The function to invoke if there was a problem removing any of the\n   *         key-value pairs.\n   * @return {Stork.Promise}\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  removeMany: function(keys, success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.removeMany, arguments, promise ) ) \n    {\n      return promise;\n    }\n\n    var values = [];\n    var removed = 0;\n\n    var addValue = function(i)\n    {\n      return function(value) \n      {\n        values[ i ] = value;\n\n        if ( ++removed === keys.length ) \n        {\n          promise.$success( [values, keys] );\n        }\n      }\n    };\n    var setFailure = function(e) \n    {\n      promise.$failure( [values, removed, e] );\n    };\n\n    for (var i = 0; i < keys.length; i++)\n    {\n      this.remove( keys[ i ], addValue( i ), setFailure )\n    }\n\n    return promise;\n  },\n\n  /**\n   * The format of success callback for {@link Stork#each}.\n   * \n   * @callback Stork~eachSuccess\n   * @param {Any} value\n   *        The value of the current key-value pair.\n   * @param {Any} key\n   *        The key of the current key-value pair.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#each}.\n   * \n   * @callback Stork~eachFailure\n   * @param {Any} error \n   *        The error that was thrown.\n   */\n\n  /**\n   * Returns every key-value pair individually to the given callback.\n   *\n   * *Usage*\n   * ```javascript\n   * var onPairFunc = function(value, key) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(error) {\n   *   // uh oh!\n   * };\n   * db.each( onPairFunc ); // I don't care about whether it fails\n   * db.each( onPairFunc, onFailureFunc ); // listen for success & failure\n   * ```\n   * \n   * @param  {Stork~eachSuccess} callback\n   *         The function to invoke for each key-value pair.\n   * @param  {Stork~eachFailure} [failure]\n   *         The function to invoke if there was a problem iterating the \n   *         key-value pairs.\n   * @return {Stork}\n   *         The reference to this Stork instance.\n   */\n  each: function(callback, failure)\n  {\n    if ( !isFunc( callback ) || this.handlePending( this.each, arguments ) ) \n    {\n      return this;\n    }\n\n    var stork = this;\n    var iterate = function(values, keys)\n    {\n      for (var i = 0; i < values.length; i++)\n      {\n        callback.call( stork, values[ i ], keys[ i ] );\n      }\n    };\n\n    if ( this.loaded )\n    {\n      var keys = this.cache.okeys;\n      var values = this.cache.values;\n\n      iterate( values, keys );\n    }\n    else\n    {\n      this.reload( iterate, failure );\n    }\n\n    return this;\n  },\n\n  /**\n   * The format of success callback for {@link Stork#size}.\n   * \n   * @callback Stork~sizeSuccess\n   * @param {Number} count\n   *        The total number of key-value pairs.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#size}.\n   * \n   * @callback Stork~sizeFailure\n   * @param {Any} error \n   *        The error that was thrown.\n   */\n\n  /**\n   * Returns the number of key-value pairs to the success callback.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(count) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(error) {\n   *   // uh oh!\n   * };\n   * db.size( onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.size().then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   * \n   * @param  {Stork~sizeSuccess} [success]\n   *         The function to invoke with the number of key-value pairs.\n   * @param  {Stork~sizeFailure} [failure]\n   *         The function to invoke if there was a problem determining the\n   *         number of key-value pairs.\n   * @return {Stork.Promise}\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  size: function(success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.size, arguments, promise ) ) \n    {\n      return promise;\n    }\n\n    if ( this.loaded )\n    {\n      promise.$success( [this.cache.size()] );\n    }\n    else\n    {\n      this._size( promise );\n    }\n\n    return promise;\n  },\n\n  _size: function(promise)\n  {\n    throw 'Stork._size is not implemented';\n  },\n  \n  /**\n   * The format of success callback for {@link Stork#all}.\n   * \n   * @callback Stork~allSuccess\n   * @param {Array} values\n   *        An array of all values stored. This should not be modified.\n   * @param {Array} keys\n   *        An array of all keys stored. This should not be modified.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#all}.\n   * \n   * @callback Stork~allFailure\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Returns all key-value pairs to the success callback.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(values, keys) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(error) {\n   *   // uh oh!\n   * };\n   * db.all( onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.all().then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   * \n   * @param  {Stork~allSuccess} [success]\n   *         The function to invoke with all the key-value pairs.\n   * @param  {Stork~allFailure} [failure]\n   *         The function to invoke if this Stork was unable to return all of the key-value pairs.\n   * @return {Stork.Promise}\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  all: function(success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.all, arguments, promise ) ) \n    {\n      return promise;\n    }\n\n    var returnAll = function(values, keys)\n    {\n      promise.$success( [values, keys] );\n    };\n    var onFailure = function(error)\n    {\n      promise.$failure( [error] );\n    };\n\n    if ( this.loaded )\n    {\n      var keys = this.cache.okeys;\n      var values = this.cache.values;\n\n      returnAll( values, keys );\n    }\n    else\n    {\n      this.reload( returnAll, onFailure );\n    }\n\n    return promise;\n  }\n\n};\n\n","\n/**\n * Instantiates a new Promise. \n *\n * @constructor\n * @memberOf Stork\n * @param {Object} context\n *        The `this` to apply to the success, failure, and error callbacks.\n * @param {function} [success]\n *        A success callback to add to be invoked.\n * @param {function} [failure]\n *        A failure callback to add to be invoked.\n * @param {Stork.Promise} [root]\n *        The root promise, if one exists.\n */\nfunction Promise(context, success, failure, root)\n{\n  /**\n   * The `this` to apply to the callbacks.\n   * \n   * @type {Object}\n   */\n  this.context = context;\n\n  /**\n   * The root promise in the chain of promises.\n   * \n   * @type {Promise}\n   */\n  this.root = root || this;\n\n  /**\n   * The next promise in the chain of promises.\n   * \n   * @type {Promise}\n   */\n  this.next = null;\n\n  /**\n   * The first valid promise returned from a success callback.\n   * @private\n   * \n   * @type {Promise}\n   */\n  this.nextFromSuccess = null;\n\n  /**\n   * The current state of this promise.\n   * \n   * @type {Number}\n   * @default Promise.PENDING\n   */\n  this.state = Promise.PENDING;\n\n  /**\n   * An array of success callbacks to invoke when the promise is marked as\n   * successful.\n   * \n   * @type {function[]}\n   */\n  this.successes = [];\n\n  /**\n   * An array of failure callbacks to invoke when the promise is marked as\n   * failed.\n   * \n   * @type {function[]}\n   */\n  this.failures = [];\n\n  /**\n   * An array of error callbacks stored at the root promise.\n   * \n   * @type {function[]}\n   */\n  this.errors = [];\n\n  /**\n   * An array of arguments that are to be passed to the success or failure \n   * callbacks.\n   * \n   * @type {Array}\n   */\n  this.args = null;\n\n  // Queue the passed in success & failure callbacks.\n  this.$queue( success, failure );\n}\n\n/**\n * Promise is awaiting for a success or failure notification.\n * @type {Number}\n */\nPromise.PENDING = 0;\n\n/**\n * Promise has been marked as a failure.\n * @type {Number}\n */\nPromise.FAILURE = 1;\n\n/**\n * Promise has been marked as a success.\n * @type {Number}\n */\nPromise.SUCCESS = 2;\n\n/**\n * Promise has been marked as a success and the next promise has been notified.\n * @type {Number}\n */\nPromise.CHAINED = 3;\n\nPromise.prototype = \n{\n  /**\n   * Adds success and optionally a failure callback to be invoked when the \n   * promised operation completes. The success callback can return a promise \n   * to chain promises.\n   * \n   * @param  {function} success\n   *         The function to invoke with the success arguments.\n   * @param  {function} [failure]\n   *         The function to invoke with the failure arguments.\n   * @return {Stork.Promise}\n   *         The next promise to invoke when the returned promise from the \n   *         success callback finishes.\n   */\n  then: function(success, failure)\n  {\n    this.$queue( success, failure );  \n\n    if ( !this.next )\n    {\n      this.next = new Promise( this.context, undefined, undefined, this );\n    }\n   \n    if ( this.state & Promise.SUCCESS ) \n    {\n      this.$handleSuccesses();\n    } \n    else if ( this.state === Promise.FAILURE ) \n    {\n      this.$handleFailures();\n    }\n\n    return this.next;\n  },\n\n  /**\n   * Adds a generic error to be called if any of the promises in the chain have\n   * failed.\n   * \n   * @param  {function} error\n   *         A function to invoke if any of the promises fail.\n   * @return {Stork.Promise}\n   *         A reference to this promise.\n   */\n  error: function(error)\n  {\n    if ( isFunc( error ) )\n    {\n      this.root.errors.push( error );\n\n      if ( this.state === Promise.FAILURE )\n      {\n        this.$handleFailures();\n      }  \n    }\n\n    return this;\n  },\n\n  // When the given promise finishes it will finish this promise as well.\n  $bindTo: function(to, replacementArguments)\n  {\n    var from = this;\n\n    to.then(\n      function() {\n        from.context = to.context;\n        from.$success( coalesce( replacementArguments, to.args ) );\n      },\n      function() {\n        from.context = to.context;\n        from.$failure( coalesce( replacementArguments, to.args ) );\n      })\n    ;\n  },\n\n  // Returns true if the promise has yet to finish.\n  $pending: function()\n  {\n    return this.state === Promise.PENDING;\n  },\n\n  // Adds a success and/or failure callback to this promise.\n  $queue: function(success, failure)\n  {\n    if ( isFunc( success ) ) this.successes.push( success );\n    if ( isFunc( failure ) ) this.failures.push( failure );\n  },\n\n  // Executes all successes currently on the promise.\n  $handleSuccesses: function()\n  {\n    var succs = this.successes;\n    for (var i = 0; i < succs.length; i++) \n    {\n      var s = succs[ i ];\n      var result = s.apply( this.context, this.args );\n\n      if ( result instanceof Promise && !this.nextFromSuccess ) \n      {\n        this.nextFromSuccess = result;\n      }\n    }\n\n    succs.length = 0;\n\n    this.$handleNext();\n  },\n\n  // If a next promise is given and one of the success callbacks return a \n  // promise, this promise is bound to the returned promise to complete the \n  // link in the chain.\n  $handleNext: function()\n  {\n    var next = this.next;\n    var returned = this.nextFromSuccess;\n\n    if (next && returned && this.state === Promise.SUCCESS)\n    {\n      next.$bindTo( returned );\n      this.state = Promise.CHAINED;\n    }\n  },\n\n  // Marks this promise as a success if the promise hasn't finished yet.\n  $success: function(args)\n  {\n    if ( this.state === Promise.PENDING ) \n    {\n      this.args = args || [];\n      this.state = Promise.SUCCESS;\n      this.$handleSuccesses();\n    }\n  },\n\n  // Executes all failures currently on the promise.\n  $handleFailures: function()\n  {\n    var fails = this.failures;\n    for (var i = 0; i < fails.length; i++) \n    {\n      fails[ i ].apply( this.context, this.args );\n    }\n    fails.length = 0;\n\n    var errors = this.root.errors;\n    var errorArgument = [ this.args[ this.args.length - 1 ] ];\n    for (var i = 0; i < errors.length; i++)\n    {\n      errors[ i ].apply( this.context, errorArgument );\n    }\n    errors.length = 0;\n  },\n\n  // Marks this promise as a failure if the promise hasn't finished yet.\n  $failure: function(args)\n  {\n    if ( this.state === Promise.PENDING ) \n    {\n      this.args = args || [];\n      this.state = Promise.FAILURE;\n      this.$handleFailures();\n    }\n  }\n\n};","\n/**\n * A FastMap has the key-to-value benefits of a map and iteration benefits of an\n * array. This is especially beneficial when most of the time the contents of \n * the structure need to be iterated and order doesn't matter (since removal \n * performs a swap which breaks insertion order).\n *\n * @constructor\n * @memberOf Stork\n * @param {Stork.FastMap|object} [map]\n */\nfunction FastMap(map)\n{\n  this.reset();\n  this.putMap( map );\n}\n\nFastMap.prototype =\n{\n\n  /**\n   * Resets the map by initializing the values, keys, and indexes.\n   * \n   * @return {Stork.FastMap}\n   */\n  reset: function()\n  {\n    /**\n     * An array of the values in this map.\n     * @member {Array}\n     */\n    this.values = [];\n\n    /**\n     * An array of the keys in this map.\n     * @type {Array}\n     */\n    this.keys = [];\n\n    /**\n     * An array of the original keys in this map.\n     * @type {Array}\n     */\n    this.okeys = [];\n\n    /**\n     * An object of key to index mappings.\n     * @type {Object}\n     */\n    this.indices = {};\n\n    return this;\n  },\n\n  /**\n   * Puts the value in the map by the given key.\n   *\n   * @param {String} key\n   * @param {V} value\n   * @param {K} originalKey\n   * @return {Stork.FastMap}\n   */\n  put: function(key, value, originalKey)\n  {\n    if ( key in this.indices )\n    {\n      this.values[ this.indices[ key ] ] = value;\n    }\n    else\n    {\n      this.indices[ key ] = this.values.length;\n      this.values.push( value );\n      this.keys.push( key );\n      this.okeys.push( originalKey );\n    }\n\n    return this;\n  },\n\n  /**\n   * Puts all keys & values on the given map into this map overwriting any existing values mapped by similar keys.\n   *\n   * @param {FastMap|Object} map\n   * @return {Stork.FastMap}\n   */\n  putMap: function(map)\n  {\n    if (map instanceof FastMap)\n    {\n      var keys = map.keys;\n      var values = map.values;\n      var okeys = map.okeys;\n\n      for (var i = 0; i < keys.length; i++)\n      {\n        this.put( keys[ i ], values[ i ], okeys[ i ] );\n      }\n    }\n    else if ( isObject( map ) )\n    {\n      for (var key in map)\n      {\n        this.put( key, map[ key ], key );\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Returns the value mapped by the given key.\n   *\n   * @param {String} key\n   * @return {V}\n   */\n  get: function(key)\n  {\n    return this.values[ this.indices[ key ] ];\n  },\n\n  /**\n   * Removes the value by a given key\n   *\n   * @param {String} key\n   * @return {Stork.FastMap}\n   */\n  remove: function(key)\n  {\n    var index = this.indices[ key ];\n\n    if ( isNumber( index ) )\n    {\n      this.removeAt( index );\n    }\n\n    return this;\n  },\n\n  /**\n   * Removes the value & key at the given index.\n   *\n   * @param {Number} index\n   * @return {Stork.FastMap}\n   */\n  removeAt: function(index)\n  {\n    var key = this.keys[ index ];\n    var lastValue = this.values.pop();\n    var lastKey = this.keys.pop();\n    var lastOkey = this.okeys.pop();\n\n    if ( index < this.values.length )\n    {\n      this.values[ index ] = lastValue;\n      this.keys[ index ] = lastKey;\n      this.okeys[ index ] = lastOkey; \n      this.indices[ lastKey ] = index;\n    }\n\n    delete this.indices[ key ];\n\n    return this;\n  },\n\n  /**\n   * Returns the index of the value in the array given a key.\n   *\n   * @param {String} key\n   * @return {Number}\n   */\n  indexOf: function(key)\n  {\n    return coalesce( this.indices[ key ], -1 );\n  },\n\n  /**\n   * Returns whether this map has a value for the given key.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n  has: function(key)\n  {\n    return key in this.indices;\n  },\n\n  /**\n   * Returns whether the given input has overlap with keys in this map.\n   *\n   * @param {FastMap|Object} map\n   * @return {Boolean}\n   */\n  hasOverlap: function(map)\n  {\n    var keys = this.keys;\n    var indices = map.indices;\n\n    for (var i = 0; i < keys.length; i++)\n    {\n      if ( keys[i] in indices )\n      {\n        return true;\n      }\n    }\n   \n    return false;\n  },\n\n  /**\n   * Returns the number of elements in the map.\n   *\n   * @return {Number}\n   */\n  size: function()\n  {\n    return this.values.length;\n  }\n\n};","\n/**\n * An array of all plugin `function`s invoked on a Stork instance when it's created.\n * \n * @type {Array}\n * @see {@link Stork.plugin}\n */\nStork.plugins = [];\n\n/**\n * Adds a plugin function to be invoked on every Stork instance that's created.\n * Each plugin function is invoked after an adapter is chosen and integrated,\n * but before the {@link Stork#init} function is called.\n *\n * *Example*\n * ```javascript\n * Stork.plugin(function(stork) {\n *   var oldPut = stork.put;\n *   stork.put = function(key, value, success, failure) {\n *     // before put\n *     var promise = oldPut.apply( this, arguments );\n *     // after put, listen to promise?\n *     return promise;\n *   };\n * });\n * ```\n * \n * @param  {Stork~plugin} definition \n *         The function invoked on every Stork instance.\n * @return {Stork} The Stork namespace.\n */\nStork.plugin = function(definition)\n{\n  if ( isFunc( definition ) ) \n  {\n    Stork.plugins.push( definition ); \n  }\n\n  return Stork;\n};\n\n/**\n * @callback Stork~plugin\n * @param {Stork} stork The Stork instance to run the plugin on.\n */\n\n/**\n * An array of adapters available for implementing a Stork instance. Each item\n * in the array is an object with three properties: `String` name, `Number` \n * priority, and `Object` definition.\n * \n * @type {Array}\n * @see {@link Stork.adapter}\n */\nStork.adapters = [];\n\n/**\n * Adds an adapter available for Stork to use if it's supported.\n *\n * *Example*\n * ```javascript\n * Stork.adapter('myadapter', 7, {\n *   valid: function() { ... },\n *   init: function(options, success, failure) { ... },\n *   reload: function(success, failure) { ... },\n *   _get: function(key, rawKey, promise) { ... },\n *   _destroy: function(promise) { ... },\n *   _put: function(key, value, rawKey, rawValue, promise) { ... },\n *   _remove: function(key, rawKey, value, promise) { ... },\n *   _size: function(promise) { ... }\n * });\n * ```\n * \n * @param  {String} name       \n *         The name of the adapter. Must be unique.\n * @param  {Number} priority\n *         The priority of this adapter. The higher the value the earlier\n *         it's checked for support and is used by Stork instances.\n * @param  {function|Object} definition \n *         The definition of the adapter which is either an object of methods \n *         to overwrite for the Stork instance, or a function which returns a \n *         similar object.\n * @return {Stork} The Stork namespace.\n */\nStork.adapter = function(name, priority, definition)\n{\n  Stork.adapters.push(\n  {\n    name: name,\n    priority: priority,\n    definition: isFunc( definition ) ? definition() : definition\n  });\n\n  return Stork;\n};","\nStork.adapter('chrome-storage-local', 4, function()\n{\n  var store = window.chrome && chrome.storage ? chrome.storage.local : false;\n\n  function isError() \n  {\n    return chrome && chrome.runtime && chrome.runtime.lastError;\n  };\n\n  return {\n\n    encode: function(key)\n    {\n      return this.prefix + toJson( key );\n    },\n\n    decode: function(rawKey)\n    {\n      return fromJson( rawKey.substring( this.prefix.length ) );\n    },\n\n    valid: function() \n    {\n      if (!store) \n      {\n        return false;\n      }\n\n      try \n      {\n        var temp = Math.random();\n        var map = {};\n\n        map[ temp ] = temp;\n        store.set( map );\n        store.remove( temp );\n\n        return true;\n      } \n      catch (e) \n      {\n        return false;\n      }\n    },\n\n    init: function(options, success, failure) \n    {\n      var promise = new Promise( this, success, failure );\n      \n      this.prefix = coalesce( options.prefix, this.name + '-' );\n\n      if ( this.lazy )\n      {\n        this._finishInitialization( promise, [this] );\n      }\n      else\n      {\n        promise.$bindTo( this.reload(), [this] );\n      }\n\n      return promise;\n    },\n\n    reload: function(success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n      var stork = this;\n      var prefix = this.prefix;\n      var cache = new FastMap();\n\n      store.get( null, function(items)\n      {\n        if ( isError() )\n        {\n          promise.$failure( [isError()] );\n        }\n        else\n        {\n          for (var rawKey in items)\n          {\n            if ( rawKey.substring( 0, prefix.length ) === prefix )\n            {\n              cache.put( rawKey, items[ rawKey ], stork.decode( rawKey ) );\n            }\n          }\n\n          stork.cache = cache;\n          stork.loaded = true;\n\n          stork.finishReload( promise );\n        }\n\n      });\n\n      return promise;\n    },\n\n    _get: function(key, rawKey, promise)\n    {\n      store.get( rawKey, function(items)\n      {\n        if ( isError() )\n        {\n          promise.$failure( [key, isError()] );\n        }\n        else\n        {\n          if ( items.length )\n          {\n            var value = fromJson( items[0] );\n\n            promise.$success( [value, key] );\n          }\n          else\n          {\n            promise.$success( [undefined, key] );\n          }\n        }\n      });\n    },\n\n    _destroy: function(promise)\n    {\n      var stork = this;\n      var removeByKeys = function()\n      {\n        store.remove( this.cache.keys, function()\n        {\n          if ( isError() ) \n          {\n            promise.$failure( [isError()] );\n          }\n          else \n          {\n            stork.cache.reset();\n\n            promise.$success();\n          }\n        });\n      };\n      var onFailure = function(e)\n      {\n        promise.$failure( [e] );\n      };\n\n      if ( this.loaded )\n      {\n        removeByKeys();\n      }\n      else\n      {\n        this.reload( removeByKeys, onFailure );\n      }\n    },\n\n    _put: function(key, value, rawKey, rawValue, promise)\n    {\n      var stork = this;\n      var obj = {};\n\n      obj[ rawKey ] = value;\n\n      store.set( obj, function() \n      {\n        if ( isError() ) \n        {\n          promise.$failure( [key, value, isError()] );\n        } \n        else \n        {\n          var previousValue = stork.cache.get( rawKey );\n\n          stork.cache.put( rawKey, value, key );\n\n          promise.$success( [key, value, previousValue] );\n        }\n      });\n    },\n\n    _remove: function(key, rawKey, value, promise)\n    {  \n      var stork = this;\n\n      store.remove( rawKey, function()\n      {\n        if ( isError() )\n        {\n          promise.$failure( [key, isError()] );\n        }\n        else\n        {\n          stork.cache.remove( rawKey );\n\n          promise.$success( [value, key] );\n        }\n      });\n    },\n\n    _size: function(promise)\n    {\n      var onSuccess = function(keys, values)\n      {\n        promise.$success( [keys.length] );\n      };\n      var onFailure = function(e)\n      {\n        promise.$failure( [e] );\n      };\n\n      this.reload( onSuccess, onFailure );\n    }\n\n  }\n});","\nStork.adapter('local-storage', 3, function()\n{\n  var store = window.localStorage;\n\n  return {\n\n    encode: function(key)\n    {\n      return this.prefix + toJson( key );\n    },\n\n    decode: function(rawKey)\n    {\n      return fromJson( rawKey.substring( this.prefix.length ) );\n    },\n\n    valid: function()\n    {\n      if (!store) \n      {\n        return false;\n      }\n      try \n      {\n        var temp = Math.random();\n        store.setItem( temp, temp );\n        store.removeItem( temp );\n\n        return true;\n      } \n      catch (e) \n      {\n        return false;\n      }\n    },\n\n    init: function(options, success, failure) \n    {\n      var promise = new Promise( this, success, failure );\n\n      this.prefix = coalesce( options.prefix, this.name + '-' );\n\n      if ( this.lazy )\n      {\n        this.finishInitialization( promise, [this] );\n      }\n      else\n      {\n        promise.$bindTo( this.reload(), [this] );\n      }\n\n      return promise;\n    },\n\n    reload: function(success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n      var prefix = this.prefix;\n      var cache = new FastMap();\n\n      try\n      {\n        for (var i = 0; i < store.length; i++)\n        {\n          var rawKey = store.key( i );\n\n          if ( rawKey.substring( 0, prefix.length ) === prefix )\n          {\n            var rawValue = store.getItem( rawKey );\n            var value = fromJson( rawValue );\n            var key = this.decode( rawKey );\n\n            cache.put( rawKey, value, key );\n          }  \n        }\n\n        this.cache = cache;\n        this.loaded = true;\n      }\n      catch (e)\n      {\n        promise.$failure( [e] );\n      }\n\n      this.finishReload( promise );\n\n      return promise;\n    },\n\n    _destroy: function(promise)\n    {\n      var stork = this;\n      var prefix = this.prefix;\n      var removeByKeys = function( keys )\n      {\n        try\n        {\n          for (var i = 0; i < keys.length; i++)\n          {\n            store.removeItem( keys[ i ] );\n          }\n        }\n        catch (e)\n        {\n          promise.$failure( [e] );\n        }\n\n        if ( promise.$pending() )\n        {\n          stork.cache.reset();\n\n          promise.$success();\n        }\n      };\n      \n      if ( this.loaded )\n      {\n        removeByKeys( this.cache.keys );\n      }\n      else\n      {\n        var keys = [];\n\n        try\n        {\n          for (var i = 0; i < store.length; i++)\n          {\n            var rawKey = store.key( i );\n\n            if ( rawKey.substring( 0, prefix.length ) === prefix )\n            {\n              keys.push( rawKey );\n            }\n          }  \n        }\n        catch (e)\n        {\n          promise.$failure( [e] );\n        }\n\n        if ( promise.$pending() )\n        {\n          removeByKeys( keys );          \n        }\n      }\n    },\n\n    _get: function(key, rawKey, promise)\n    {\n      try\n      { \n        var rawValue = store.getItem( rawKey );\n        var value = fromJson( rawValue );\n\n        promise.$success( [value, key] );\n      }\n      catch (e)\n      {\n        promise.$failure( [key, e] );\n      }\n    },\n\n    _put: function(key, value, rawKey, rawValue, promise)\n    {\n      try\n      {\n        store.setItem( rawKey, rawValue );        \n      }\n      catch (e)\n      {\n        promise.$failure( [key, value, e] );\n      }\n\n      if ( promise.$pending() )\n      {\n        var previousValue = this.cache.get( rawKey );\n\n        this.cache.put( rawKey, value, key );\n\n        promise.$success( [key, value, previousValue] );\n      }\n    },\n\n    _remove: function(key, rawKey, value, promise)\n    {\n      try\n      {\n        store.removeItem( rawKey );\n      }\n      catch (e)\n      {\n        promise.$failure( [key, e] );\n      }\n\n      if ( promise.$pending() )\n      {\n        this.cache.remove( rawKey );\n\n        promise.$success( [value, key] );\n      }\n    },\n\n    _size: function(promise)\n    {\n      var onSuccess = function(keys, values)\n      {\n        promise.$success( [keys.length] );\n      };\n      var onFailure = function(e)\n      {\n        promise.$failure( [e] );\n      };\n\n      this.reload( onSuccess, onFailure );\n    }\n\n  }\n});","\nStork.adapter('memory', 1, \n{\n  valid: function() \n  {\n    return true;\n  },\n\n  init: function(options, success, failure) \n  {\n    var promise = new Promise( this, success, failure );\n\n    this.loaded = true;\n    this.finishInitialization( promise, [this] );\n    \n    return promise;\n  },\n\n  reload: function(success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    this.finishReload( promise );\n\n    return promise;\n  },\n\n  _destroy: function(promise)\n  {\n    this.cache.reset();\n\n    promise.$success();\n  },\n\n  _put: function(key, value, rawKey, rawValue, promise)\n  {\n    var previousValue = this.cache.get( rawKey );\n\n    this.cache.put( rawKey, value, key );\n\n    promise.$success( [key, value, previousValue] );\n  },\n\n  _remove: function(key, rawKey, value, promise)\n  {\n    this.cache.remove( rawKey );\n\n    promise.$success( [value, key] );\n  }\n\n});","\nStork.adapter('webkit-sqlite', 5, function()\n{\n  var DATABASE_NAME = 'stork';\n\n  var SQL_CREATE = 'CREATE TABLE IF NOT EXISTS {0} (id TEXT PRIMARY KEY, value TEXT)';\n  var SQL_SELECT  = 'SELECT value FROM {0} WHERE id = ?';\n  var SQL_SELECT_ALL = 'SELECT id, value FROM {0}';\n  var SQL_INSERT = 'INSERT OR REPLACE INTO {0} (id, value) VALUES (?, ?)';\n  var SQL_DELETE = 'DELETE FROM {0} WHERE id = ?';\n  var SQL_COUNT = 'SELECT COUNT(*) as count FROM {0}';\n  var SQL_DESTROY = 'DELETE FROM {0}';\n  var SQL_DELETE_MANY = 'DELETE FROM {0} WHERE id IN ({1})';\n\n  function streplace(str, arr)\n  {\n    return str.replace(/\\{(\\d+)\\}/g, function(match, index)\n    {\n      index = parseInt( index );\n\n      if ( isNaN( index ) || index < 0 || index >= arr.length ) \n      {\n        return match;\n      }\n\n      return arr[ index ];\n    });\n  }\n\n  return {\n\n    valid: function() \n    {\n      return !!window.openDatabase;\n    },\n\n    init: function(options, success, failure) \n    {\n      var promise = new Promise( this, success, failure );\n\n      var databaseName = coalesce( options.database, DATABASE_NAME );\n      var databaseSize = coalesce( options.size, 65536 );\n      var databaseVersion = coalesce( options.version, '1.0' );\n\n      var stork = this;\n\n      var onFailure = function(tx, error) \n      {\n        promise.$failure( [error] );\n      };\n      var onTransactionForCreate = function(tx) \n      {\n        tx.executeSql( stork.SQL_CREATE, [], onCreate, onFailure );\n      };\n      var onCreate = function(tx, results) \n      {\n        if ( stork.lazy )\n        {\n          stork.finishInitialization( promise, [stork] );\n        }\n        else\n        {\n          promise.$bindTo( stork.reload(), [stork] );\n        }\n      };\n\n      this.SQL_CREATE     = streplace( SQL_CREATE, [this.name] );\n      this.SQL_SELECT     = streplace( SQL_SELECT, [this.name] );\n      this.SQL_SELECT_ALL = streplace( SQL_SELECT_ALL, [this.name] );\n      this.SQL_INSERT     = streplace( SQL_INSERT, [this.name] );\n      this.SQL_DELETE     = streplace( SQL_DELETE, [this.name] );\n      this.SQL_DESTROY    = streplace( SQL_DESTROY, [this.name] );\n      this.SQL_COUNT      = streplace( SQL_COUNT, [this.name] );\n\n      this.db = openDatabase( databaseName, databaseVersion, databaseName, databaseSize );\n      this.db.transaction( onTransactionForCreate, onFailure );\n      \n      return promise;\n    },\n\n    reload: function(success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n      var stork = this;\n\n      var onFailure = function(tx, error) \n      {\n        promise.$failure( [error] );\n      };\n      var onTransactionForSelect = function(tx) \n      {\n        tx.executeSql( stork.SQL_SELECT_ALL, [], onResults, onFailure );\n      };\n      var onResults = function(tx, results) \n      {\n        var cache = new FastMap();\n        try \n        {\n          for (var i = 0; i < results.rows.length; i++) \n          {\n            var record = results.rows[ i ];\n            var value = fromJson( record.value );\n            var key = fromJson( record.id );\n\n            cache.put( record.id, value, key );\n          }\n\n          stork.cache = cache;\n          stork.loaded = true;\n        }\n        catch (e) \n        {\n          promise.$failure( [e] );\n        }\n\n        stork.finishReload( promise );\n      };\n\n      this.db.readTransaction( onTransactionForSelect, onFailure );\n\n      return promise;\n    },\n\n    _get: function(key, rawKey, promise)\n    {\n      var stork = this;\n\n      var onFailure = function(tx, error) \n      {\n        promise.$failure( [key, error] );\n      };\n      var onTransaction = function(tx)\n      {\n        tx.executeSql( stork.SQL_SELECT, [rawKey], onResult, onFailure );\n      };\n      var onResult = function(tx, results)\n      {\n        var value = undefined;\n        try\n        {\n          var first = results.rows[ 0 ];\n\n          if ( first && first.value !== undefined )\n          {\n            value = fromJson( first.value );\n          }\n        }\n        catch (e)\n        {\n          promise.$failure( [key, e] );\n        }\n\n        if ( promise.$pending() )\n        {\n          if ( value !== undefined )\n          {\n            stork.cache.put( rawKey, value, key );\n\n            promise.$success( [value, key] );\n          }\n          else\n          {\n            promise.$success( [undefined, key] );\n          }\n        }\n      };\n\n      this.db.readTransaction( onTransaction, onFailure );\n    },\n\n    _destroy: function(promise)\n    {\n      var stork = this;\n\n      var onTransaction = function(tx) \n      {\n        tx.executeSql( stork.SQL_DESTROY, [], onSuccess, onFailure );\n      };\n      var onSuccess = function(tx, results) \n      {\n        stork.cache.reset();\n\n        promise.$success();\n      };\n      var onFailure = function(tx, error) \n      {\n        promise.$failure( [error] );\n      };\n\n      this.db.transaction( onTransaction, onFailure );\n    },\n\n    _put: function(key, value, rawKey, rawValue, promise)\n    {\n      var stork = this;\n      \n      var onTransaction = function(tx) \n      {\n        tx.executeSql( stork.SQL_INSERT, [rawKey, rawValue], onSuccess, onFailure );\n      };\n      var onSuccess = function(tx, results) \n      {\n        var previousValue = stork.cache.get( rawKey );\n\n        stork.cache.put( rawKey, value );\n\n        promise.$success( [key, value, previousValue] );\n      };\n      var onFailure = function(tx, error) \n      {\n        promise.$failure( [key, value, error] );\n      };\n\n      this.db.transaction( onTransaction, onFailure );\n    },\n\n    batch: function(records, success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n\n      if ( this.handlePending( this.batch, arguments, promise ) ) \n      {\n        return promise;\n      }\n\n      var stork = this;\n      var keyName = this.key;\n      var successful = 0;\n      var converted = [];\n\n      try\n      {\n        for (var i = 0; i < records.length; i++)\n        {\n          var value = records[ i ];\n          var key = value[ keyName ];\n\n          if ( undef(key) ) \n          {\n            key = value[ keyName ] = uuid();\n          }\n\n          converted.push(\n          {\n            value: value,\n            key: key,\n            rawKey: toJson( key ), \n            rawValue: toJson( value )\n          });\n        }  \n      }\n      catch (e)\n      {\n        promise.$failure( [records, successful, e] );\n\n        return promise;\n      }\n\n      var onTransaction = function(tx) \n      { \n        for (var i = 0; i < converted.length; i++)\n        {\n          var record = converted[ i ];\n\n          tx.executeSql( stork.SQL_INSERT, [record.rawKey, record.rawValue], onSuccess, onFailure );\n        }\n      };\n      var onSuccess = function(tx, results) \n      {\n        if ( ++successful === records.length && promise.$pending() )\n        {\n          for (var i = 0; i < converted.length; i++)\n          {\n            var record = converted[ i ];\n\n            stork.cache.put( record.rawKey, record.value, record.key );\n          }\n\n          promise.$success( [records] );\n        }\n      };\n      var onFailure = function(tx, error) \n      {\n        promise.$failure( [records, successful, error] );\n      };\n\n      this.db.transaction( onTransaction, onFailure );     \n\n      return promise;\n    },\n\n    _remove: function(key, rawKey, value, promise)\n    {\n      var stork = this;\n      \n      var onTransaction = function(tx) \n      {\n        tx.executeSql( stork.SQL_DELETE, [rawKey], onSuccess, onFailure );\n      };\n      var onSuccess = function(tx, results) \n      {\n        stork.cache.remove( rawKey );\n\n        promise.$success( [value, key] );\n      };\n      var onFailure = function(tx, error) \n      {\n        promise.$failure( [key, error] );\n      };\n\n      this.db.transaction( onTransaction, onFailure );\n    },\n\n    removeMany: function(keys, success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n\n      if ( this.handlePending( this.removeMany, arguments, promise ) ) \n      {\n        return promise;\n      }\n      \n      var stork = this;\n      var rawKeys = [];\n      var values = []; \n      var binder = [];\n      var query = '';\n\n      var onTransaction = function(tx) \n      {\n        tx.executeSql( query, rawKeys, onSuccess, onFailure );\n      };\n      var onSuccess = function(tx, results) \n      {\n        for (var i = 0; i < rawKeys.length; i++) \n        {\n          stork.cache.remove( rawKeys[ i ] );\n        }\n\n        promise.$success( [values, keys] );\n      };\n      var onFailure = function(tx, error) \n      {\n        promise.$failure( [values, 0, error] );\n      };\n\n      try\n      {\n        for (var i = 0; i < keys.length; i++) \n        {\n          var key = toJson( keys[ i ] );\n\n          if ( this.cache.has( key ) )\n          {\n            rawKeys[ i ] = key;\n            values[ i ] = this.cache.get( key );\n            binder[ i ] = '?';\n          }\n        }\n\n        query = streplace( SQL_DELETE_MANY, [this.name, binder.join(',')] );\n      }\n      catch (e)\n      {\n        promise.$failure( [values, e] );\n      }\n\n      if ( promise.$pending() )\n      {\n        this.db.transaction( onTransaction, onFailure );\n      }\n\n      return promise;\n    },\n\n    _size: function(promise)\n    {\n      var stork = this;\n\n      var onFailure = function(tx, error) \n      {\n        promise.$failure( [error] );\n      };\n      var onTransaction = function(tx)\n      {\n        tx.executeSql( stork.SQL_COUNT, [], onCount, onFailure );\n      };\n      var onCount = function(tx, results)\n      {\n        promise.$success( [results.rows[0].count] );\n      };\n\n      this.db.readTransaction( onTransaction, onFailure );\n    },\n\n  }\n});","\nStork.adapter('window-name', 2, function()\n{\n\n  function loadData()\n  {\n    if ( !loadData.cache )\n    {\n      try\n      {\n        loadData.cache = fromJson( window.top.name );\n      }\n      catch (e)\n      {\n        loadData.cache = {};\n      }\n    }\n    \n    return loadData.cache;\n  }\n\n  function saveData()\n  {\n    try\n    {\n      window.top.name = toJson( loadData() );\n    }\n    catch (e)\n    {\n\n    }\n  }\n\n  return {\n\n    encode: function(key)\n    {\n      return this.prefix + toJson( key );\n    },\n\n    decode: function(rawKey)\n    {\n      return fromJson( rawKey.substring( this.prefix.length ) );\n    },\n\n    valid: function() \n    {\n      return window.top && typeof window.top.name !== 'undefined';\n    },\n\n    init: function(options, success, failure) \n    {\n      var promise = new Promise( this, success, failure );\n\n      this.prefix = coalesce( options.prefix, this.name + '-' );\n\n      promise.$bindTo( this.reload(), [this] );\n      \n      return promise;\n    },\n\n    reload: function(success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n      var prefix = this.prefix;\n      var cache = new FastMap();\n      var data = loadData();\n\n      try\n      {\n        for (var rawKey in data)\n        {\n          if ( rawKey.substring( 0, prefix.length ) === prefix )\n          {\n            var rawValue = data[ rawKey ];\n            var value = fromJson( rawValue );\n            var key = this.decode( rawKey );\n\n            cache.put( rawKey, value, key );\n          }  \n        }\n\n        this.cache = cache;\n        this.loaded = true;\n      }\n      catch (e)\n      {\n        promise.$failure( [e] );\n      }\n\n      this.finishReload( promise );\n\n      return promise;\n    },\n\n    _destroy: function(promise)\n    {\n      var keys = this.cache.keys;\n      var data = loadData();\n\n      for (var i = 0; i < keys.length; i++)\n      {\n        delete data[ keys[i] ];\n      }\n\n      this.cache.reset();\n\n      saveData();\n\n      promise.$success();\n    },\n\n    _put: function(key, value, rawKey, rawValue, promise)\n    {\n      var data = loadData();\n      var previousValue = this.cache.get( rawKey );\n\n      data[ rawKey ] = value;\n\n      this.cache.put( rawKey, value, key );\n\n      saveData();\n\n      promise.$success( [key, value, previousValue] );\n    },\n\n    _remove: function(key, rawKey, value, promise)\n    {\n      var data = loadData();\n\n      delete data[ rawKey ];\n\n      this.cache.remove( rawKey );\n\n      saveData();\n\n      promise.$success( [value, key] );\n    }\n\n  }\n});","\n  \n  global.Stork = Stork;\n  global.Stork.getAdapter = getAdapter;\n  global.Stork.Promise = Promise;\n  global.Stork.FastMap = FastMap;\n\n})(window);"],"sourceRoot":"/source/"}