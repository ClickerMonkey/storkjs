{"version":3,"sources":["header.js","functions.js","Stork.js","Promise.js","FastMap.js","footer.js","extending.js","aggregation.js","query.js","chrome-storage-local.js","ie-userdata.js","indexed-db.js","local-storage.js","memory.js","webkit-sqlite.js","window-name.js"],"names":["root","factory","define","amd","module","exports","global","Stork","this","undefined","isFunc","x","constructor","call","apply","isObject","isNumber","isNaN","isArray","Array","isString","undef","def","replaceArray","dest","src","length","push","coalesce","a","b","c","d","swap","arr","i","j","temp","copy","from","to","prop","S4","Math","random","toString","substring","uuid","compareAdapters","priority","$promise","methodName","func","promise","Promise","success","failure","handlePending","arguments","args","prototype","slice","pop","getAdapter","adapterName","adapters","adapt","name","definition","valid","chosen","sort","options","JSON","key","lazy","cache","FastMap","pending","initialized","loaded","adapter","plugins","initializing","init","context","next","nextPromise","state","PENDING","successes","failures","errors","chainFailureResult","$queue","map","values","keys","okeys","indices","putMap","toJson","stringify","fromJson","parse","decode","encode","method","handled","$reset","finishInitialization","$success","newPromise","$bindTo","finishReload","$pending","reload","then","callback","getMany","Group","addValue","value","onFailure","e","$failure","get","rawKey","has","_get","destroy","_destroy","reset","_resetPromise","rawKeys","rawValues","_reset","onSaved","setFailure","onDestroyed","valuePromise","_put","save","record","keyName","onSuccess","error","put","batch","records","saves","rawValue","remove","_remove","removeMany","removed","each","stork","iterate","size","_size","all","returnAll","FAILURE","SUCCESS","CHAINED","$handleSuccesses","$handleFailures","either","complete","replacementArguments","succs","s","result","$handleNext","returned","fails","f","errorArgument","$clear","$stop","Done","groupSize","group","count","originalKey","index","removeAt","overwrite","rebuildIndex","lastValue","lastKey","lastOkey","indexOf","hasOverlap","reverse","max","half","ceil","comparator","partition","left","right","pivot","floor","qsort","l","plugin","aggregate","property","accumulate","getResult","v","total","sum","summing","avg","min","minValue","Number","MAX_VALUE","maxValue","METHODS","where","condition","matchedKeys","matchedValues","k","select","columns","results","resultKeys","resultObject","resultColumns","desc","isError","chrome","runtime","lastError","store","window","storage","local","prefix","set","_finishInitialization","items","removeByKeys","obj","previousValue","document","body","addBehavior","createElement","style","behavior","position","appendChild","load","attributes","XMLDocument","firstChild","nodeName","nodeValue","getAttribute","removeAttribute","setAttribute","getIDB","indexedDB","webkitIndexedDB","mozIndexedDB","oIndexedDB","msIndexedDB","getIDBTransaction","IDBTransaction","webkitIDBTransaction","mozIDBTransaction","oIDBTransaction","msIDBTransaction","DATABASE_VERSION","READ_WRITE","request","open","onerror","onupgradeneeded","db","createObjectStore","keyPath","onsuccess","event","objectStore","transaction","cursor","openCursor","oncomplete","onabort","clear","localStorage","setItem","removeItem","getItem","streplace","str","replace","match","parseInt","DATABASE_NAME","SQL_CREATE","SQL_SELECT","SQL_SELECT_ALL","SQL_SELECT_MANY","SQL_INSERT","SQL_DELETE","SQL_COUNT","SQL_DESTROY","SQL_DELETE_MANY","openDatabase","databaseName","database","databaseSize","databaseVersion","version","tx","onTransactionForCreate","executeSql","onCreate","onTransactionForSelect","onResults","rows","id","readTransaction","onTransaction","onResult","first","onCount","successful","converted","binder","query","join","keyToValueIndex","r","loadData","top","saveData","data"],"mappings":"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","file":"stork.min.js","sourcesContent":["'use strict';\n\n// UMD (Universal Module Definition)\n(function (root, factory)\n{\n  if (typeof define === 'function' && define.amd) // jshint ignore:line\n  {\n    // AMD. Register as an anonymous module.\n    define('Stork', [], function() { // jshint ignore:line\n      return factory(root);\n    });\n  }\n  else if (typeof module === 'object' && module.exports)  // jshint ignore:line\n  {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory(global);  // jshint ignore:line\n  }\n  else\n  {\n    // Browser globals (root is window)\n    root.Stork = factory(root);\n  }\n}(this, function(global, undefined)\n{\n","var toJson = JSON.stringify;\n\nvar fromJson = JSON.parse;\n\nfunction isFunc(x)\n{\n  return !!(x && x.constructor && x.call && x.apply);\n}\n\nfunction isObject(x)\n{\n  return typeof x === 'object' && x !== null;\n}\n\nfunction isNumber(x)\n{\n  return typeof x === 'number' && !isNaN(x);\n}\n\nfunction isArray(x)\n{\n  return x instanceof Array;\n}\n\nfunction isString(x)\n{\n  return typeof x === 'string';\n}\n\nfunction undef(x)\n{\n  return typeof x === 'undefined';\n}\n\nfunction def(x)\n{\n  return typeof x !== 'undefined';\n}\n\nfunction replaceArray(dest, src)\n{\n  dest.length = 0;\n  dest.push.apply( dest, src );\n}\n\nfunction coalesce(a, b, c, d)\n{\n  if (def(a)) return a;\n  if (def(b)) return b;\n  if (def(c)) return c;\n  return d;\n}\n\nfunction swap(arr, i, j)\n{\n  var temp = arr[i]; \n  arr[i] = arr[j]; \n  arr[j] = temp;\n}\n\nfunction noop()\n{\n}\n\nfunction fn(func)\n{\n  return isFunc( func ) ? func : noop;\n}\n\nfunction fncoalesce(a, b)\n{\n  return isFunc( a ) ? a : (isFunc(b) ? b : noop);\n}\n\nfunction copy(from, to)\n{\n  for (var prop in from)\n  {\n    to[ prop ] = from[ prop ];\n  }\n\n  return to;\n}\n\nfunction S4() \n{\n  return (((1+Math.random())*0x10000)|0).toString(16).substring(1);\n}\n\nfunction uuid() \n{\n    return (S4()+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+S4()+S4());\n}\n\nfunction compareAdapters(a, b)\n{\n  var d = b.priority - a.priority;\n\n  return d === 0 ? 0 : (d < 0 ? -1 : 1);\n}\n\nfunction $promise(methodName, func)\n{\n  return function()\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this[ methodName ], arguments, promise ) ) \n    {\n      return promise;\n    }\n\n    var args = Array.prototype.slice.call( arguments );\n    args.pop(); // remove failure\n    args.pop(); // remove success\n    args.push( promise ); // add promise\n\n    // Call the wrapped function\n    func.apply( this, args );\n\n    return promise;\n  };\n}\n\nfunction getAdapter(adapterName)\n{\n  if ( adapterName )\n  {\n    for (var i = 0; i < Stork.adapters.length; i++) \n    {\n      var adapt = Stork.adapters[i];\n\n      if ( adapt.name === adapterName && adapt.definition.valid() )\n      {\n        return adapt;\n      }\n    }\n  }\n\n  if ( !getAdapter.chosen ) \n  {\n    Stork.adapters.sort( compareAdapters );\n\n    for (var i = 0; i < Stork.adapters.length; i++) \n    {\n      var adapt = Stork.adapters[i];\n\n      if ( adapt.definition.valid() )\n      {\n        return getAdapter.chosen = adapt;\n      }\n    }\n  }\n\n  return getAdapter.chosen;\n}","\n\n/**\n * Creates a Stork instance.\n *\n * ```javascript\n * new Stork(); // global key-values/records\n * new Stork({name: 'todos'}); // grouped key-values/records\n * new Stork({name: 'rooms', key: 'ID'}); // records have 'ID' property which is used as key for saving records\n * new Stork({name: 'you are', lazy: true}); // records aren't all loaded on start, they are loaded as needed\n * new Stork({name: 'users', database: 'myapp', size: 65536}); // some storage engines support a custom database name and a desired size for the database\n *\n * new Stork(options, function(stork) {\n *   // stork = initialized stork instance\n * });\n * ```\n *\n * @constructor\n * @class\n * @param {Object} [options]\n *        An object of options, see the following properties for more details:\n *        {@link Stork#key}, {@link Stork#name}, {@link Stork#lazy}.\n * @param {Stork~initSuccess} [success]\n *        The function to invoke when the instance successfully initializes.\n * @param {Stork~initFailure} [failure]\n *        The function to invoke if this instance failes to initialize.\n */\nfunction Stork(options, success, failure)\n{\n  // If this wasn't called as a constructor, return an instance!\n  if (!(this instanceof Stork)) return new Stork( options, success, failure );\n\n  // JSON is required for StorkJS\n  if (!JSON) throw 'JSON unavailable! Include http://www.json.org/json2.js to fix.';\n\n  /**\n   * The options passed to the constructor and subsequently to the\n   * {@link Stork#init} function.\n   *\n   * @type {Object}\n   * @default  {}\n   */\n  this.options = options = (options || {});\n\n  /**\n   * The name of the property to use as the key for the\n   * {@link Stork#save} and {@link Stork#batch} functions. This should\n   * be specified in the `options` object.\n   *\n   * @type {String}\n   * @default 'id'\n   */\n  this.key = coalesce( options.key, 'id' );\n\n  /**\n   * The name used to group the key-value pairs. This is essentially\n   * a table name. This should be specified in the `options` object.\n   *\n   * @type {String}\n   * @default ''\n   */\n  this.name = coalesce( options.name, '' );\n\n  /**\n   * If true, key-value pairs will be lazily loaded instead of loaded\n   * all at once on initialization. This should be specified in the\n   * `options` object.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.lazy = coalesce( options.lazy, false );\n\n  /**\n   * The cache of key-value pairs currently loaded. If\n   * {@link Stork#loaded} is true then all key-value pairs exist in\n   * the cache.\n   *\n   * @type {FastMap}\n   */\n  this.cache = new FastMap();\n\n  /**\n   * An array of functions called by the user before this instances\n   * was finished initializing. Once this instance successfully finishes\n   * initialization all pending functions are invoked in the order\n   * in which they were originally made and this property is set to\n   * `null`.\n   *\n   * @type {Object[]}\n   */\n  this.pending = [];\n\n  /**\n   * True if this instance has successfully initialized, otherwise\n   * false if it failed to initialize or has not finished initializing.\n   *\n   * @type {Boolean}\n   */\n  this.initialized = false;\n\n  /**\n   * True if the entire instance has been loaded into the\n   * {@link Stork#cache}, otherwise false. If lazy is specifed as true\n   * loaded will be false until any of the following methods are\n   * invoked: {@link Stork#each}, {@link Stork#all}, or\n   * {@link Stork#reload}.\n   *\n   * @type {Boolean}\n   */\n  this.loaded = false;\n\n  /**\n   * The adapter `Object` with `String` name, `Number` priority, and\n   * `Object` definition properties. The adapter can be chosen based\n   * on the `options.adapter` and falls back to the next supported\n   * adapter based on priority.\n   *\n   * @type {Object}\n   */\n  this.adapter = getAdapter( options.adapter );\n\n  // Copy the chosen adapter methods into this instance.\n  copy( this.adapter.definition, this );\n\n  // Call each plugin on this instance before initialization starts.\n  for (var i = 0; i < Stork.plugins.length; i++)\n  {\n    Stork.plugins[ i ]( this );\n  }\n\n  // Start initializaing this instance.\n  this.initializing = this.init( this.options, success, failure );\n}\n\nStork.prototype =\n{\n\n  /**\n   * Decodes a key from a string.\n   *\n   * @method decode\n   * @param {String} rawKey\n   *        The string to decode into a key.\n   * @return {Any}\n   */\n  decode: fromJson,\n\n  /**\n   * Encodes a key into a string.\n   *\n   * @method encode\n   * @param {Any} key\n   *        The key to encode to a string.\n   * @return {String}\n   */\n  encode: toJson,\n\n  /**\n   * Returns true if this Stork is not ready for storage calls and queues\n   * the method and arguments to be called after this Stork is initialized.\n   *\n   * @private\n   * @param  {function} method\n   *         The reference to the calling function\n   * @param  {Arguments} args\n   *         The arguments of the calling function\n   * @param  {Stork.Promise} promise\n   *         The promise to notify when the function is finally called.\n   * @return {Boolean} -\n   *         Returns true if the calling function should return this\n   *         immediately because the implementation isn't initialized yet.\n   */\n  handlePending: function(method, args, promise)\n  {\n    var handled = !this.initialized;\n\n    if (handled)\n    {\n      this.pending.push(\n      {\n        method: method,\n        arguments: Array.prototype.slice.call( args ),\n        promise: promise\n\n      });\n\n      if ( promise )\n      {\n        promise.$reset();\n      }\n    }\n\n    return handled;\n  },\n\n  /**\n   * Marks the Stork as initialized and executes any pending functions.\n   *\n   * @private\n   * @param  {Stork.Promise} promise\n   *         The promise for {@link Stork#init} or {@link Stork#reload}.\n   * @return {Stork} -\n   *         A reference to this.\n   */\n  finishInitialization: function(promise, args)\n  {\n    if (!this.initialized)\n    {\n      this.initialized = true;\n\n      promise.$success( args );\n\n      for (var i = 0; i < this.pending.length; i++)\n      {\n        var pending = this.pending[ i ];\n        var newPromise = pending.method.apply( this, pending.arguments );\n\n        if ( pending.promise )\n        {\n          pending.promise.$bindTo( newPromise );\n        }\n      }\n\n      this.pending = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * Finishes the reload function passing the now cached values and keys\n   * to the success callbacks.\n   *\n   * @private\n   * @param  {Stock.Promise} promise\n   *         The promise for the {@link Stork#reload} invocation.\n   */\n  finishReload: function(promise)\n  {\n    if ( promise.$pending() )\n    {\n      var cache = this.cache;\n\n      if ( this.initialized )\n      {\n        promise.$success( [cache.values, cache.okeys] );\n      }\n      else\n      {\n        this.finishInitialization( promise, [cache.values, cache.okeys] );\n      }\n    }\n  },\n\n  /**\n   * Determines whether this Stork implementation is available.\n   *\n   * @return {Boolean} True if this Stork is usable, otherwise false.\n   */\n  valid: function()\n  {\n    throw 'Stork.valid is not implemented';\n  },\n\n  /**\n   * The format of success callback for {@link Stork#init}.\n   *\n   * @callback Stork~initSuccess\n   * @param {Stork} stork\n   *        The reference to this Stork instance.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#init}.\n   *\n   * @callback Stork~initFailure\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Initializes this Stork instance. If `options.lazy` is passed in as true,\n   * key-value pairs will not be loaded here, otherwise all key-value\n   * pairs will be loaded. This function is automatically called at the end\n   * of the Stork constructor with the options passed to the constructor.\n   *\n   * @param  {Object} options\n   *         The initialization options.\n   * @param  {Stork~initSuccess} [success]\n   *         The function to invoke when the Stork instance successfully\n   *         initializes and is usable.\n   * @param  {Stork~initFailure} [failure]\n   *         The function to invoke if there's a problem initializing.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  init: function(options, success, failure)\n  {\n    throw 'Stork.init is not implemented';\n  },\n\n  /**\n   * The format of success callback for {@link Stork#reload}.\n   *\n   * @callback Stork~reloadSuccess\n   * @param {Array} values\n   *        An array of all values loaded. This should not be modified.\n   * @param {Array} keys\n   *        An array of all keys loaded. This should not be modified.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#reload}.\n   *\n   * @callback Stork~reloadFailure\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Loads all key-value pairs into the cache which will increase performance\n   * for fetching operations ({@link Stork#get}, {@link Stork#getMany},\n   * {@link Stork#each}, {@link Stork#all}).\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(values, keys) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(error) {\n   *   // uh oh!\n   * };\n   * db.reload(); // I don't care about whether it succeeds or fails\n   * db.reload( onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.reload().then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   *\n   * @param  {Stork~reloadSuccess} [success]\n   *         The function to invoke when all key-value pairs are loaded.\n   * @param  {Stork~reloadFailure} [failure]\n   *         The function to invoke if there was a problem loading all key-value\n   *         pairs.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  reload: function(success, failure)\n  {\n    throw 'Stork.reload is not implemented';\n  },\n\n  /**\n   * A helper method for creating a consistent look when chaining promised\n   * functions.\n   *\n   * *Usage*\n   * ```javascript\n   * db.then(function() { // <--\n   *     // this === db, how big is it?\n   *     return this.size();\n   *   })\n   *   .then(function(size) {\n   *     // size has been determined, destroy!\n   *     return this.destroy();\n   *   })\n   *   .then(function(){\n   *     // You sunk my battleship! (destroyed db)\n   *   })\n   * ;\n   * ```\n   *\n   * @param  {function} callback\n   *         The callback to invoke with this Stork instance as `this`.\n   * @return {Stork.Promise} -\n   *         The callback should return a Promise to chain additional functions.\n   */\n  then: function(callback)\n  {\n    return callback.apply( this );\n  },\n\n  /**\n   * The format of success callback for {@link Stork#getMany}.\n   *\n   * @callback Stork~getManySuccess\n   * @param {Array} values\n   *        The array of values associated to the given keys. If a key wasn't\n   *        found then the value in the array will be `undefined`.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#getMany}.\n   *\n   * @callback Stork~getManyFailure\n   * @param {Array} keys\n   *        The keys given that resulted in an error.\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Gets an array of values given an array of keys and returns it to the\n   * callback. If the key doesn't exist then the corresponding value in the\n   * returned array will be `undefined`.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(values, keys) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(keys, error) {\n   *   // uh oh!\n   * };\n   * db.getMany( arrayOfKeys, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.getMany( arrayOfKeys ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   *\n   * @param  {Array} keys\n   *         The keys of the key-value pairs to get.\n   * @param  {Stork~getManySuccess} [success]\n   *         THe function to invoke with the values found.\n   * @param  {Stork~getManyFailure} [failure]\n   *         The function to invoke if there was a problem getting values.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  getMany: function(keys, success, failure)\n  {\n    var promise = Promise.Group( keys.length, this, success, failure );\n\n    if ( this.handlePending( this.getMany, arguments, promise ) )\n    {\n      return promise;\n    }\n\n    var values = [];\n\n    var addValue = function(i)\n    {\n      return function(value)\n      {\n        values[ i ] = value;\n\n        promise.$success( [values, keys] );\n      };\n    };\n    var onFailure = function(e)\n    {\n      promise.$failure( [keys, e] );\n    };\n\n    for (var i = 0; i < keys.length; i++)\n    {\n      this.get( keys[ i ], addValue( i ), onFailure );\n    }\n\n    return promise;\n  },\n\n  /**\n   * The format of success callback for {@link Stork#get}.\n   *\n   * @callback Stork~getSuccess\n   * @param {Any} value\n   *        The value associated to the given key or `undefined` if one was not\n   *        found.\n   * @param {Any} key\n   *        The key of the key-value pair that was successfully found.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#get}.\n   *\n   * @callback Stork~getFailure\n   * @param {Any} key\n   *        The key of the key-value pair that was unsuccessfully gotten.\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Gets the value for the given key and returns it to the callback. If the\n   * key doesn't exist then `undefined` is given to the callback.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(value, key) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(key, error) {\n   *   // uh oh!\n   * };\n   * db.get( key, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.get( key ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   *\n   * @param  {Any} key\n   *         The key of the key-value pair to get.\n   * @param  {Stork~getSuccess} [success]\n   *         The function to invoke if a value is successfully found or not found.\n   * @param  {Stork~getFailure} [failure]\n   *         The function to invoke if there was a problem.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  get: function (key, success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.get, arguments, promise ) )\n    {\n      return promise;\n    }\n\n    var rawKey;\n\n    try\n    {\n      rawKey = this.encode( key );\n    }\n    catch (e)\n    {\n      promise.$failure( [key, e] );\n    }\n\n    if ( promise.$pending() )\n    {\n      if ( this.cache.has( rawKey ) )\n      {\n        promise.$success( [this.cache.get( rawKey ), key] );\n      }\n      else if ( this.loaded )\n      {\n        promise.$success( [undefined, key] );\n      }\n      else\n      {\n        this._get( key, rawKey, promise );\n      }\n    }\n\n    return promise;\n  },\n\n  _get: function(key, rawKey, promise)\n  {\n    throw 'Stork._get is not implemented';\n  },\n\n  /**\n   * The format of success callback for {@link Stork#destroy}.\n   *\n   * @callback Stork~destroySuccess\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#destroy}.\n   *\n   * @callback Stork~destroyFailure\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Removes all key-value pairs and invokes the callback.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function() {\n   *   // DESTROYED!\n   * };\n   * var onFailureFunc = function(error) {\n   *   // uh oh!\n   * };\n   * db.destroy(); // I don't care about whether it succeeds or fails\n   * db.destroy( onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.destroy().then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   *\n   * @param  {Stork~destroySuccess} [success]\n   *         The function invoked when all key-value pairs are removed.\n   * @param  {Stork~destroyFailure} [failure]\n   *         The function invoked if there was a problem removing all key-value\n   *         pairs.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  destroy: function(success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.destroy, arguments, promise ) )\n    {\n      return promise;\n    }\n\n    this._destroy( promise );\n\n    return promise;\n  },\n\n  _destroy: function(promise)\n  {\n    throw 'Stork._destroy is not implemented';\n  },\n\n\n\n  /**\n   * The format of success callback for {@link Stork#reset}.\n   *\n   * @callback Stork~resetSuccess\n   * @param {Any[]} keys\n   *        The array of keys to reset.\n   * @param {Any[]} values\n   *        The array of values to reset.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#reset}.\n   *\n   * @callback Stork~resetFailure\n   * @param {Any[]} keys\n   *        The array of keys to reset.\n   * @param {Any[]} values\n   *        The array of values to reset.\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Resets the key-value pairs. This is equivalent to destroying and running\n   * a batch save on all the key-value pairs. Once reset the callback is\n   * invoked.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function() {\n   *   // DESTROYED!\n   * };\n   * var onFailureFunc = function(error) {\n   *   // uh oh!\n   * };\n   * db.reset([3], ['value']); // I don't care about whether it succeeds or fails\n   * db.reset([3], ['value'], onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.reset([3], ['value']).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   *\n   * @param {Any[]} keys\n   *         The array of keys to reset.\n   * @param {Any[]} values\n   *         The array of values to reset.\n   * @param  {Stork~resetSuccess} [success]\n   *         The function invoked when all key-value pairs are Reset.\n   * @param  {Stork~resetFailure} [failure]\n   *         The function invoked if there was a problem reseting all key-value\n   *         pairs.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  reset: function(keys, values, success, failure)\n  {\n    var promise = this._resetPromise( keys, values, success, failure );\n\n    if ( this.handlePending( this.reset, arguments, promise ) )\n    {\n      return promise;\n    }\n\n    var rawKeys = [], rawValues = [];\n\n    try\n    {\n      for (var i = 0; i < values.length; i++)\n      {\n        rawKeys[ i ] = this.encode( keys[ i ] );\n        rawValues[ i ] = toJson( values[ i ] );\n      }\n    }\n    catch (e)\n    {\n      promise.$failure( [keys, values, e] );\n    }\n\n    if ( promise.$pending() )\n    {\n      this._reset( keys, values, rawKeys, rawValues, promise );\n    }\n\n    return promise;\n  },\n\n  _resetPromise: function(keys, values, success, failure)\n  {\n    return Promise.Group( values.length, this, success, failure );\n  },\n\n  _reset: function(keys, values, rawKeys, rawValues, promise)\n  {\n    var onSaved = function()\n    {\n      promise.$success( [keys, values] );\n    };\n    var setFailure = function(e)\n    {\n      promise.$failure( [keys, values, e] );\n    };\n    var onDestroyed = function()\n    {\n      for (var i = 0; i < values.length && !promise.state; i++)\n      {\n        var valuePromise = new Promise( this, onSaved, setFailure );\n\n        this._put( keys[ i ], values[ i ], rawKeys[ i ], rawValues[ i ], valuePromise );\n      }\n    };\n\n    this.destroy( onDestroyed, setFailure );\n  },\n\n  /**\n   * The format of success callback for {@link Stork#save}.\n   *\n   * @callback Stork~saveSuccess\n   * @param {Object} record\n   *        The record that successfully saved.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#save}.\n   *\n   * @callback Stork~saveFailure\n   * @param {Object} record\n   *        The record that failed to save.\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Saves an `Object` record and returns the saved record to the callback. The\n   * record is the value in the key-value pair and the key is pulled from the\n   * record based on the options passed into the {@link Stork#init} function.\n   * The property used as the key is `this.key` and by default is `id`. If a key\n   * isn't specified in a record then a UUID is used and placed in the object.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(record) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(record, error) {\n   *   // uh oh!\n   * };\n   * db.save( record ); // I don't care about whether it succeeds or fails\n   * db.save( record, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.save( record ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   *\n   * @param  {Object} record\n   *         The record to save.\n   * @param  {Stork~saveSuccess} [success]\n   *         The function to invoke when the record is successfully saved.\n   * @param  {Stork~saveFailure} [failure]\n   *         The function to invoke if the record fails to save.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  save: function(record, success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.save, arguments, promise ) )\n    {\n      return promise;\n    }\n\n    var keyName = this.key;\n    var key = record[ keyName ];\n\n    if ( undef( key ) )\n    {\n      key = record[ keyName ] = uuid();\n    }\n\n    var onSuccess = function(key, value)\n    {\n      promise.$success( [value] );\n    };\n    var onFailure = function(key, value, error)\n    {\n      promise.$failure( [value, error] );\n    };\n\n    this.put( key, record, onSuccess, onFailure );\n\n    return promise;\n  },\n\n  /**\n   * The format of success callback for {@link Stork#batch}.\n   *\n   * @callback Stork~batchSuccess\n   * @param {Array} records\n   *        The records successfully saved.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#batch}.\n   *\n   * @callback Stork~batchFailure\n   * @param {Array} records\n   *        The records unsuccessfully saved.\n   * @param {Number} recordsSaved\n   *        The number of records that successfully saved.\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Saves an array of `Object` records and returns the records saved to the\n   * callback. The record is the value in the key-value pair and the key is\n   * pulled from the record based on the options passed into the\n   * {@link Stork#init} function. The property used as the key is `this.key` and\n   * by default is `id`. If a key isn't specified in a record then a UUID is\n   * used and placed in the object.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(records) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(records, recordsSaved, error) {\n   *   // uh oh!\n   * };\n   * db.batch( records ); // I don't care about whether it succeeds or fails\n   * db.batch( records, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.batch( records ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   *\n   * @param  {Array} records\n   *         The array of objects to save.\n   * @param  {Stork~batchSuccess} [success]\n   *         The function to invoke when all records are successfully saved.\n   * @param  {Stork~batchFailure} [failure]\n   *         The function to invoke if any of the records failed to save.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  batch: function(records, success, failure)\n  {\n    var promise = Promise.Group( records.length, this, success, failure );\n\n    if ( this.handlePending( this.batch, arguments, promise ) )\n    {\n      return promise;\n    }\n\n    var onSaved = function()\n    {\n      promise.$success( [records] );\n    };\n    var setFailure = function(e)\n    {\n      promise.$failure( [records, saves, e] );\n    };\n\n    for (var i = 0; i < records.length && !promise.state; i++)\n    {\n      this.save( records[ i ], onSaved, setFailure );\n    }\n\n    return promise;\n  },\n\n  /**\n   * The format of success callback for {@link Stork#put}.\n   *\n   * @callback Stork~putSuccess\n   * @param {Any} key\n   *        The key to add or update.\n   * @param {Any} value\n   *        The value to add or update.\n   * @param {Any} previousValue\n   *        The previous value for the key if it exists in the cache.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#put}.\n   *\n   * @callback Stork~putFailure\n   * @param {Any} key\n   *        The key that failed to be added or updated.\n   * @param {Any} value\n   *        The value that failed to be added or updated.\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Adds or updates the value mapped by the given key and returns the key\n   * and value placed to the callback.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(key, value, previousValue) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(key, value, error) {\n   *   // uh oh!\n   * };\n   * db.put( key, value ); // I don't care about whether it succeeds or fails\n   * db.put( key, value, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.put( key, value ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   *\n   * @param  {Any} key\n   *         The key to add or update.\n   * @param  {Any} value\n   *         The value to add or update.\n   * @param  {Stork~putSuccess} [success]\n   *         The function to invoke when the key-value pair is successfully\n   *         added or updated.\n   * @param  {Stork~putFailure} [failure]\n   *         The function to invoke if there was a problem putting the key-value\n   *         pair.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  put: function(key, value, success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.put, arguments, promise ) )\n    {\n      return promise;\n    }\n\n    var rawKey, rawValue;\n\n    try\n    {\n      rawKey = this.encode( key );\n      rawValue = toJson( value );\n    }\n    catch (e)\n    {\n      promise.$failure( [key, value, e] );\n    }\n\n    if ( promise.$pending() )\n    {\n      this._put( key, value, rawKey, rawValue, promise );\n    }\n\n    return promise;\n  },\n\n  _put: function(key, value, rawKey, rawValue, promise)\n  {\n    throw 'Stork._put is not implemented';\n  },\n\n  /**\n   * The format of success callback for {@link Stork#remove}.\n   *\n   * @callback Stork~removeSuccess\n   * @param {Any} value\n   *        The value removed or `undefined` if the key didn't exist.\n   * @param {Any} key\n   *        The key of the key-value pair that was removed.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#remove}.\n   *\n   * @callback Stork~removeFailure\n   * @param {Any} key\n   *        The key of the key-value pair that failed to be removed.\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Removes the key-value pair for the given key and returns the removed value\n   * to the callback if on existed.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(value, key) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(key, error) {\n   *   // uh oh!\n   * };\n   * db.remove( key ); // I don't care about whether it succeeds or fails\n   * db.remove( key, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.remove( key ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   *\n   * @param  {Any} key\n   *         The key of the key-value pair to remove.\n   * @param  {Stork~removeSuccess} [success]\n   *         The function to invoke then the key is removed or doesn't exist.\n   * @param  {Stork~removeFailure} [failure]\n   *         The function to invoke if there was a problem removing the key.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  remove: function(key, success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.remove, arguments, promise ) )\n    {\n      return promise;\n    }\n\n    var rawKey;\n\n    try\n    {\n      rawKey = this.encode( key );\n    }\n    catch (e)\n    {\n      promise.$failure( [key, e] );\n    }\n\n    if ( promise.$pending() )\n    {\n      if ( this.loaded && !this.cache.has( rawKey ) )\n      {\n        promise.$success( [undefined, key] );\n      }\n      else\n      {\n        var value = this.cache.get( rawKey );\n\n        this._remove( key, rawKey, value, promise );\n      }\n    }\n\n    return promise;\n  },\n\n  _remove: function(key, rawKey, value, promise)\n  {\n    throw 'Stork._remove is not implemented';\n  },\n\n  /**\n   * The format of success callback for {@link Stork#removeMany}.\n   *\n   * @callback Stork~removeManySuccess\n   * @param {Array} values\n   *        The values removed in the same order of the keys. If a key didn't\n   *        exist then the corresponding value in the array will be `undefined`.\n   * @param {Array} keys\n   *        The corresponding removed keys.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#removeMany}.\n   *\n   * @callback Stork~removeManyFailure\n   * @param {Array} values\n   *        The values removed in the same order of the given keys.\n   * @param {Number} removed\n   *        The number of records removed before the error occurred.\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Removes multiple key-value pairs and returns the values removed to the\n   * given callback.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(values, keys) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(values, removed, error) {\n   *   // uh oh!\n   * };\n   * db.removeMany( keys ); // I don't care about whether it succeeds or fails\n   * db.removeMany( keys, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.removeMany( keys ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   *\n   * @param  {Array} keys\n   *         The array of keys to remove.\n   * @param  {Stork~removeManySuccess} [success]\n   *         The function to invoke once all matching key-value pairs are\n   *         removed, with the values removed.\n   * @param  {Stork~removeManyFailure} [failure]\n   *         The function to invoke if there was a problem removing any of the\n   *         key-value pairs.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  removeMany: function(keys, success, failure)\n  {\n    var promise = Promise.Group( keys.length, this, success, failure );\n\n    if ( this.handlePending( this.removeMany, arguments, promise ) )\n    {\n      return promise;\n    }\n\n    var values = [];\n    var removed = 0;\n\n    var addValue = function(i)\n    {\n      return function(value)\n      {\n        values[ i ] = value;\n        removed++;\n\n        promise.$success( [values, keys] );\n      };\n    };\n    var setFailure = function(e)\n    {\n      promise.$failure( [values, removed, e] );\n    };\n\n    for (var i = 0; i < keys.length; i++)\n    {\n      this.remove( keys[ i ], addValue( i ), setFailure )\n    }\n\n    return promise;\n  },\n\n  /**\n   * The format of success callback for {@link Stork#each}.\n   *\n   * @callback Stork~eachSuccess\n   * @param {Any} value\n   *        The value of the current key-value pair.\n   * @param {Any} key\n   *        The key of the current key-value pair.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#each}.\n   *\n   * @callback Stork~eachFailure\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Returns every key-value pair individually to the given callback.\n   *\n   * *Usage*\n   * ```javascript\n   * var onPairFunc = function(value, key) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(error) {\n   *   // uh oh!\n   * };\n   * db.each( onPairFunc ); // I don't care about whether it fails\n   * db.each( onPairFunc, onFailureFunc ); // listen for success & failure\n   * ```\n   *\n   * @param  {Stork~eachSuccess} callback\n   *         The function to invoke for each key-value pair.\n   * @param  {Stork~eachFailure} [failure]\n   *         The function to invoke if there was a problem iterating the\n   *         key-value pairs.\n   * @return {Stork} -\n   *         The reference to this Stork instance.\n   */\n  each: function(callback, failure)\n  {\n    if ( !isFunc( callback ) || this.handlePending( this.each, arguments ) )\n    {\n      return this;\n    }\n\n    var stork = this;\n    var iterate = function(values, keys)\n    {\n      for (var i = 0; i < values.length; i++)\n      {\n        callback.call( stork, values[ i ], keys[ i ] );\n      }\n    };\n\n    if ( this.loaded )\n    {\n      var keys = this.cache.okeys;\n      var values = this.cache.values;\n\n      iterate( values, keys );\n    }\n    else\n    {\n      this.reload( iterate, failure );\n    }\n\n    return this;\n  },\n\n  /**\n   * The format of success callback for {@link Stork#size}.\n   *\n   * @callback Stork~sizeSuccess\n   * @param {Number} count\n   *        The total number of key-value pairs.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#size}.\n   *\n   * @callback Stork~sizeFailure\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Returns the number of key-value pairs to the success callback.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(count) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(error) {\n   *   // uh oh!\n   * };\n   * db.size( onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.size().then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   *\n   * @param  {Stork~sizeSuccess} [success]\n   *         The function to invoke with the number of key-value pairs.\n   * @param  {Stork~sizeFailure} [failure]\n   *         The function to invoke if there was a problem determining the\n   *         number of key-value pairs.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  size: function(success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.size, arguments, promise ) )\n    {\n      return promise;\n    }\n\n    if ( this.loaded )\n    {\n      promise.$success( [this.cache.size()] );\n    }\n    else\n    {\n      this._size( promise );\n    }\n\n    return promise;\n  },\n\n  _size: function(promise)\n  {\n    throw 'Stork._size is not implemented';\n  },\n\n  /**\n   * The format of success callback for {@link Stork#all}.\n   *\n   * @callback Stork~allSuccess\n   * @param {Array} values\n   *        An array of all values stored. This should not be modified.\n   * @param {Array} keys\n   *        An array of all keys stored. This should not be modified.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#all}.\n   *\n   * @callback Stork~allFailure\n   * @param {Any} error\n   *        The error that was thrown.\n   */\n\n  /**\n   * Returns all key-value pairs to the success callback.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(values, keys) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(error) {\n   *   // uh oh!\n   * };\n   * db.all( onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.all().then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   *\n   * @param  {Stork~allSuccess} [success]\n   *         The function to invoke with all the key-value pairs.\n   * @param  {Stork~allFailure} [failure]\n   *         The function to invoke if this Stork was unable to return all of the key-value pairs.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  all: function(success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    if ( this.handlePending( this.all, arguments, promise ) )\n    {\n      return promise;\n    }\n\n    var returnAll = function(values, keys)\n    {\n      promise.$success( [values, keys] );\n    };\n    var onFailure = function(error)\n    {\n      promise.$failure( [error] );\n    };\n\n    if ( this.loaded )\n    {\n      var keys = this.cache.okeys;\n      var values = this.cache.values;\n\n      returnAll( values, keys );\n    }\n    else\n    {\n      this.reload( returnAll, onFailure );\n    }\n\n    return promise;\n  }\n\n};\n","\n/**\n * Instantiates a new Promise. \n *\n * @constructor\n * @memberOf Stork\n * @param {Object} context\n *        The `this` to apply to the success, failure, and error callbacks.\n * @param {function} [success]\n *        A success callback to add to be invoked.\n * @param {function} [failure]\n *        A failure callback to add to be invoked.\n * @param {Stork.Promise} [root]\n *        The root promise, if one exists.\n */\nfunction Promise(context, success, failure, root)\n{\n  /**\n   * The `this` to apply to the callbacks.\n   * \n   * @type {Object}\n   */\n  this.context = context;\n\n  /**\n   * The root promise in the chain of promises.\n   * \n   * @type {Promise}\n   */\n  this.root = root || this;\n\n  /**\n   * The next promise in the chain of promises.\n   * \n   * @type {Promise}\n   */\n  this.next = null;\n\n  /**\n   * The first valid promise returned from a success callback.\n   * @private\n   * \n   * @type {Promise}\n   */\n  this.nextPromise = null;\n\n  /**\n   * The current state of this promise.\n   * \n   * @type {Number}\n   * @default Promise.PENDING\n   */\n  this.state = Promise.PENDING;\n\n  /**\n   * An array of success callbacks to invoke when the promise is marked as\n   * successful.\n   * \n   * @type {function[]}\n   */\n  this.successes = [];\n\n  /**\n   * An array of failure callbacks to invoke when the promise is marked as\n   * failed.\n   * \n   * @type {function[]}\n   */\n  this.failures = [];\n\n  /**\n   * An array of error callbacks stored at the root promise.\n   * \n   * @type {function[]}\n   */\n  this.errors = [];\n\n  /**\n   * An array of arguments that are to be passed to the success or failure \n   * callbacks.\n   * \n   * @type {Array}\n   */\n  this.args = null;\n\n  /**\n   * Whether this promise should look at the result of the failure callbacks \n   * for a promise to bind to and continue the chain.\n   * \n   * @type {boolean}\n   */\n  this.chainFailureResult = false;\n\n  // Queue the passed in success & failure callbacks.\n  this.$queue( success, failure );\n}\n\n/**\n * Promise is awaiting for a success or failure notification.\n * @type {Number}\n */\nPromise.PENDING = 0;\n\n/**\n * Promise has been marked as a failure.\n * @type {Number}\n */\nPromise.FAILURE = 1;\n\n/**\n * Promise has been marked as a success.\n * @type {Number}\n */\nPromise.SUCCESS = 2;\n\n/**\n * Promise has been marked as a success and the next promise has been notified.\n * @type {Number}\n */\nPromise.CHAINED = 3;\n\n\nPromise.prototype = \n{\n  /**\n   * Adds success and optionally a failure callback to be invoked when the \n   * promised operation completes. The success callback can return a promise \n   * to chain promises.\n   * \n   * @param  {function} success\n   *         The function to invoke with the success arguments.\n   * @param  {function} [failure]\n   *         The function to invoke with the failure arguments.\n   * @return {Stork.Promise} -\n   *         The next promise to invoke when the returned promise from the \n   *         success callback finishes.\n   */\n  then: function(success, failure)\n  {\n    this.$queue( success, failure );  \n\n    if ( !this.next )\n    {\n      this.next = new Promise( this.context, undefined, undefined, this );\n    }\n   \n    if ( this.state & Promise.SUCCESS ) \n    {\n      this.$handleSuccesses();\n    } \n    else if ( this.state === Promise.FAILURE ) \n    {\n      this.$handleFailures();\n    }\n\n    return this.next;\n  },\n\n  /**\n   * Adds a callback to be invoked when either a success or failure occurs on\n   * this promise. If a promise is returned by the callback - once that promise\n   * completes the next promise will be processed on either success or failure.\n   * \n   * @param  {function} complete\n   *         The function to invoke when either a success or a failure occurs.\n   * @return {Stork.Promise} - \n   *         The next promise to invoke when the returned promise from the\n   *         success callback finishes.\n   */\n  either: function(complete)\n  {\n    this.chainFailureResult = true;\n\n    return this.then( complete, complete );\n  },\n\n  /**\n   * Adds a generic error to be called if any of the promises in the chain have\n   * failed.\n   * \n   * @param  {function} error\n   *         A function to invoke if any of the promises fail.\n   * @return {Stork.Promise} -\n   *         A reference to this promise.\n   */\n  error: function(error)\n  {\n    if ( isFunc( error ) )\n    {\n      this.root.errors.push( error );\n\n      if ( this.state === Promise.FAILURE )\n      {\n        this.$handleFailures();\n      }  \n    }\n\n    return this;\n  },\n\n  // When the given promise finishes it will finish this promise as well.\n  $bindTo: function(to, replacementArguments)\n  {\n    var from = this;\n\n    to.then(\n      function() {\n        from.context = to.context;\n        from.$success( coalesce( replacementArguments, to.args ) );\n      },\n      function() {\n        from.context = to.context;\n        from.$failure( coalesce( replacementArguments, to.args ) );\n      })\n    ;\n  },\n\n  // Returns true if the promise has yet to finish.\n  $pending: function()\n  {\n    return this.state === Promise.PENDING;\n  },\n\n  // Adds a success and/or failure callback to this promise.\n  $queue: function(success, failure)\n  {\n    if ( isFunc( success ) ) this.successes.push( success );\n    if ( isFunc( failure ) ) this.failures.push( failure );\n  },\n\n  // Executes all successes currently on the promise.\n  $handleSuccesses: function()\n  {\n    var succs = this.successes;\n    for (var i = 0; i < succs.length; i++) \n    {\n      var s = succs[ i ];\n      var result = s.apply( this.context, this.args );\n\n      if ( result instanceof Promise && !this.nextPromise ) \n      {\n        this.nextPromise = result;\n      }\n    }\n\n    succs.length = 0;\n\n    this.$handleNext();\n  },\n\n  // If a next promise is given and one of the success callbacks return a \n  // promise, this promise is bound to the returned promise to complete the \n  // link in the chain.\n  $handleNext: function()\n  {\n    var next = this.next;\n    var returned = this.nextPromise;\n\n    if (next && returned && (this.state === Promise.SUCCESS || (this.state === Promise.FAILURE && this.chainFailureResult)))\n    {\n      next.$bindTo( returned );\n\n      this.state = Promise.CHAINED;\n    }\n  },\n\n  // Marks this promise as a success if the promise hasn't finished yet.\n  $success: function(args)\n  {\n    if ( this.state === Promise.PENDING ) \n    {\n      this.args = args || [];\n      this.state = Promise.SUCCESS;\n      this.$handleSuccesses();\n    }\n\n    return this;\n  },\n\n  // Executes all failures currently on the promise.\n  $handleFailures: function()\n  {\n    var fails = this.failures;\n    for (var i = 0; i < fails.length; i++) \n    {\n      var f = fails[ i ];\n      var result = f.apply( this.context, this.args );\n\n      if ( this.chainFailureResult && result instanceof Promise && !this.nextPromise )\n      {\n        this.nextPromise = result;\n      }\n    }\n\n    fails.length = 0;\n\n    var errors = this.root.errors;\n    var errorArgument = [ this.args[ this.args.length - 1 ] ];\n\n    for (var i = 0; i < errors.length; i++)\n    {\n      errors[ i ].apply( this.context, errorArgument );\n    }\n\n    errors.length = 0;\n\n    this.$handleNext();\n  },\n\n  // Marks this promise as a failure if the promise hasn't finished yet.\n  $failure: function(args)\n  {\n    if ( this.state === Promise.PENDING ) \n    {\n      this.args = args || [];\n      this.state = Promise.FAILURE;\n      this.$handleFailures();\n    }\n\n    return this;\n  },\n\n  // Resets this promise removing all listeners\n  $reset: function() \n  {\n    this.state = Promise.PENDING;\n    this.chainFailureResult = false;\n    this.$clear();\n    this.$stop();\n\n    return this;\n  },\n\n  // Removes all listeners\n  $clear: function()\n  {\n    this.successes.length = 0;\n    this.failures.length = 0;\n    this.errors.length = 0;\n\n    return this;\n  },\n\n  // Stops any chained promises from getting called if they haven't been\n  // called already.\n  $stop: function()\n  {\n    this.next = null;\n    this.nextPromise = null;\n\n    return this;\n  }\n\n};\n\n\n\n/**\n * Creates a Promise that has already successfully ran.\n * \n * @param {Object} context\n *        The `this` to apply to the success, failure, and error callbacks.\n * @return {Stork.Promise}\n *         The promise created.\n */\nPromise.Done = function(context)\n{\n  return new Promise( context ).$success();\n};\n\n/**\n * Creates a Promise that waits for a given number of success to be considered\n * a success, any failure will cause subsequent successes to be ignored.\n * \n * @param {Number} groupSize\n *        The number of $success calls that need to be made for the promise to\n *        actually be considered a success.\n * @param {Object} context\n *        The `this` to apply to the success, failure, and error callbacks.\n * @param {function} [success]\n *        A success callback to add to be invoked.\n * @param {function} [failure]\n *        A failure callback to add to be invoked.\n */\nPromise.Group = function(groupSize, context, success, failure)\n{\n  var group = new Promise( context, success, failure );\n  var count = 0;\n  var $success = group.$success;\n\n  // Override it! Inefficient, but easiest for now.\n  group.$success = function( args )\n  {\n    if ( this.state === Promise.PENDING )\n    {\n      if ( ++count === groupSize )\n      {\n        $success.call( group, args );\n      }\n    }\n  };\n\n  return group;\n};","\n/**\n * A FastMap has the key-to-value benefits of a map and iteration benefits of an\n * array. This is especially beneficial when most of the time the contents of \n * the structure need to be iterated and order doesn't matter (since removal \n * performs a swap which breaks insertion order).\n *\n * @constructor\n * @memberOf Stork\n * @param {Stork.FastMap|object} [map]\n */\nfunction FastMap(map)\n{\n  /**\n   * An array of the values in this map.\n   * @member {Array}\n   */\n  this.values = [];\n\n  /**\n   * An array of the keys in this map.\n   * @type {Array}\n   */\n  this.keys = [];\n\n  /**\n   * An array of the original keys in this map.\n   * @type {Array}\n   */\n  this.okeys = [];\n\n  /**\n   * An object of key to index mappings.\n   * @type {Object}\n   */\n  this.indices = {};\n\n  // If another map is given to populate this map, do it!\n  this.putMap( map );\n}\n\nFastMap.prototype =\n{\n\n  /**\n   * Resets the map by initializing the values, keys, and indexes.\n   * \n   * @return {Stork.FastMap}\n   */\n  reset: function()\n  {\n    this.values.length = 0;\n    this.keys.length = 0;\n    this.okeys.length = 0;\n    this.indices = {};\n\n    return this;\n  },\n\n  /**\n   * Puts the value in the map by the given key.\n   *\n   * @param {String} key\n   * @param {V} value\n   * @param {K} originalKey\n   * @return {Stork.FastMap}\n   */\n  put: function(key, value, originalKey)\n  {\n    if ( key in this.indices )\n    {\n      this.values[ this.indices[ key ] ] = value;\n    }\n    else\n    {\n      this.indices[ key ] = this.values.length;\n      this.values.push( value );\n      this.keys.push( key );\n      this.okeys.push( originalKey );\n    }\n\n    return this;\n  },\n\n  /**\n   * Puts all keys & values on the given map into this map overwriting any existing values mapped by similar keys.\n   *\n   * @param {FastMap|Object} map\n   * @return {Stork.FastMap}\n   */\n  putMap: function(map)\n  {\n    if (map instanceof FastMap)\n    {\n      var keys = map.keys;\n      var values = map.values;\n      var okeys = map.okeys;\n\n      for (var i = 0; i < keys.length; i++)\n      {\n        this.put( keys[ i ], values[ i ], okeys[ i ] );\n      }\n    }\n    else if ( isObject( map ) )\n    {\n      for (var key in map)\n      {\n        this.put( key, map[ key ], key );\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Returns the value mapped by the given key.\n   *\n   * @param {String} key\n   * @return {V}\n   */\n  get: function(key)\n  {\n    return this.values[ this.indices[ key ] ];\n  },\n\n  /**\n   * Removes the value by a given key\n   *\n   * @param {String} key\n   * @return {Stork.FastMap}\n   */\n  remove: function(key)\n  {\n    var index = this.indices[ key ];\n\n    if ( isNumber( index ) )\n    {\n      this.removeAt( index );\n    }\n\n    return this;\n  },\n\n  /**\n   * Overwrites this map with another map.\n   * \n   * @param  {Stork.FastMap} map\n   * @return {Stork.FastMap}\n   */\n  overwrite: function(map)\n  {\n    replaceArray( this.values, map.values );\n    replaceArray( this.keys, map.keys );\n    replaceArray( this.okeys, map.okeys );\n\n    this.rebuildIndex();\n\n    return this;\n  },\n\n  /**\n   * Removes the value & key at the given index.\n   *\n   * @param {Number} index\n   * @return {Stork.FastMap}\n   */\n  removeAt: function(index)\n  {\n    var key = this.keys[ index ];\n    var lastValue = this.values.pop();\n    var lastKey = this.keys.pop();\n    var lastOkey = this.okeys.pop();\n\n    if ( index < this.values.length )\n    {\n      this.values[ index ] = lastValue;\n      this.keys[ index ] = lastKey;\n      this.okeys[ index ] = lastOkey; \n      this.indices[ lastKey ] = index;\n    }\n\n    delete this.indices[ key ];\n\n    return this;\n  },\n\n  /**\n   * Returns the index of the value in the array given a key.\n   *\n   * @param {String} key\n   * @return {Number}\n   */\n  indexOf: function(key)\n  {\n    return coalesce( this.indices[ key ], -1 );\n  },\n\n  /**\n   * Returns whether this map has a value for the given key.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n  has: function(key)\n  {\n    return key in this.indices;\n  },\n\n  /**\n   * Returns whether the given input has overlap with keys in this map.\n   *\n   * @param {FastMap|Object} map\n   * @return {Boolean}\n   */\n  hasOverlap: function(map)\n  {\n    var keys = this.keys;\n    var indices = map.indices;\n\n    for (var i = 0; i < keys.length; i++)\n    {\n      if ( keys[i] in indices )\n      {\n        return true;\n      }\n    }\n   \n    return false;\n  },\n\n  /**\n   * Returns the number of elements in the map.\n   *\n   * @return {Number}\n   */\n  size: function()\n  {\n    return this.values.length;\n  },\n\n  /**\n   * Reverses the order of the underlying values & keys.\n   * \n   * @return {Stork.FastMap} -\n   *         The referense to this map.\n   */\n  reverse: function()\n  {\n    var max = this.size() - 1;\n    var half = Math.ceil( max / 2 );\n\n    for (var i = 0; i < half; i++)\n    {\n      swap( this.values, i, max - i );\n      swap( this.keys, i, max - i );\n      swap( this.okeys, i, max - i );\n    }\n\n    this.rebuildIndex();\n\n    return this;\n  },\n\n  /**\n   * Sorts the underlying values & keys given a value compare function.\n   * \n   * @param  {function} comparator\n   *         A function which accepts two values and returns a number used for\n   *         sorting. If the first argument is less than the second argument, a\n   *         negative number should be returned. If the arguments are equivalent\n   *         then 0 should be returned, otherwise a positive number should be\n   *         returned.\n   * @return {Stork.FastMap} -\n   *         The reference to this map.\n   */\n  sort: function(comparator)\n  {\n    var map = this;\n\n    // Sort this partition!\n    function partition(left, right)\n    {\n      var pivot = map.values[ Math.floor((right + left) / 2) ];\n      var i = left;\n      var j = right;\n\n      while (i <= j) \n      {\n        while (comparator( map.values[i], pivot ) < 0) i++\n        while (comparator( map.values[j], pivot ) > 0) j--;\n\n        if (i <= j) {\n          swap( map.values, i, j );\n          swap( map.keys, i, j );\n          swap( map.okeys, i, j );\n          i++;\n          j--;\n        }\n      }\n\n      return i;\n    }\n\n    // Quicksort\n    function qsort(left, right)\n    {\n      var index = partition( left, right );\n\n      if (left < index - 1) \n      {\n        qsort( left, index - 1 );\n      }\n\n      if (index < right) \n      {\n        qsort( index, right );\n      }\n    }\n\n    var right = this.size() - 1;\n\n    // Are there elements to sort?\n    if ( right > 0 )\n    {\n      qsort( 0, right );\n\n      this.rebuildIndex();\n    }\n\n    return this;\n  },\n\n  /**\n   * Rebuilds the index based on the keys.\n   * \n   * @return {Stork.FastMap} -\n   *         The reference to this map.\n   */\n  rebuildIndex: function()\n  {\n    this.indices = {};\n\n    for (var i = 0, l = this.keys.length; i < l; i++)\n    {\n      this.indices[ this.keys[ i ] ] = i;\n    }\n\n    return this;\n  }\n\n};","\n  Stork.getAdapter = getAdapter;\n  Stork.Promise = Promise;\n  Stork.FastMap = FastMap;\n\n  return Stork;\n\n}));\n","\n/**\n * An array of all plugin `function`s invoked on a Stork instance when it's created.\n * \n * @type {Array}\n * @see {@link Stork.plugin}\n */\nStork.plugins = [];\n\n/**\n * Adds a plugin function to be invoked on every Stork instance that's created.\n * Each plugin function is invoked after an adapter is chosen and integrated,\n * but before the {@link Stork#init} function is called.\n *\n * *Example*\n * ```javascript\n * Stork.plugin(function(stork) {\n *   var oldPut = stork.put;\n *   stork.put = function(key, value, success, failure) {\n *     // before put\n *     var promise = oldPut.apply( this, arguments );\n *     // after put, listen to promise?\n *     return promise;\n *   };\n * });\n * ```\n * \n * @param  {Stork~plugin} definition \n *         The function invoked on every Stork instance.\n * @return {Stork} -\n *         The Stork namespace.\n */\nStork.plugin = function(definition)\n{\n  if ( isFunc( definition ) ) \n  {\n    Stork.plugins.push( definition ); \n  }\n\n  return Stork;\n};\n\n/**\n * @callback Stork~plugin\n * @param {Stork} stork The Stork instance to run the plugin on.\n */\n\n/**\n * An array of adapters available for implementing a Stork instance. Each item\n * in the array is an object with three properties: `String` name, `Number` \n * priority, and `Object` definition.\n * \n * @type {Array}\n * @see {@link Stork.adapter}\n */\nStork.adapters = [];\n\n/**\n * Adds an adapter available for Stork to use if it's supported.\n *\n * *Example*\n * ```javascript\n * Stork.adapter('myadapter', 7, {\n *   valid: function() { ... },\n *   init: function(options, success, failure) { ... },\n *   reload: function(success, failure) { ... },\n *   _get: function(key, rawKey, promise) { ... },\n *   _destroy: function(promise) { ... },\n *   _put: function(key, value, rawKey, rawValue, promise) { ... },\n *   _remove: function(key, rawKey, value, promise) { ... },\n *   _size: function(promise) { ... }\n * });\n * ```\n * \n * @param  {String} name       \n *         The name of the adapter. Must be unique.\n * @param  {Number} priority\n *         The priority of this adapter. The higher the value the earlier\n *         it's checked for support and is used by Stork instances.\n * @param  {function|Object} definition \n *         The definition of the adapter which is either an object of methods \n *         to overwrite for the Stork instance, or a function which returns a \n *         similar object.\n * @return {Stork} - \n *         The Stork namespace.\n */\nStork.adapter = function(name, priority, definition)\n{\n  Stork.adapters.push(\n  {\n    name: name,\n    priority: priority,\n    definition: isFunc( definition ) ? definition() : definition\n  });\n\n  return Stork;\n};","Stork.plugin((function()\n{\n\n  /**\n   * The format of success callback for aggregation functions.\n   * \n   * @callback Stork~aggregateSuccess\n   * @param {Number} aggregatedValue\n   *        The result of the aggregation function.\n   */\n\n  /**\n   * The format of failure callback for aggregation functions.\n   * \n   * @callback Stork~aggregateFailure\n   * @param {Any} error \n   *        The error that was thrown.\n   */\n  \n  /**\n   * The format of an accumulation callback for aggregation functions.\n   *\n   * @callback Stork~aggregateAccumulate\n   * @param {Any} value\n   *        The value to process for accumulation.\n   */\n  \n  /**\n   * The format of an accumulation callback for aggregation functions.\n   *\n   * @callback Stork~aggregateResult\n   * @return {Any}\n   *         The result of the accumulated values.\n   */\n\n  /**\n   * Performs an aggregation on key-value pairs where the value is an `Object` \n   * which may have a specific property to aggregate. The result of the \n   * aggregation is returned to the callback.\n   *\n   * This is part of the aggregation plugin.\n   * \n   * @memberOf Stork#\n   * @param  {String} property\n   *         The property on the object to pass to the accumulation function.\n   * @param  {Stork~aggregateAccumulate} accumulate\n   *         The function to invoke with the value of the property.\n   * @param  {Stork~aggregateResult} getResult\n   *         The function to call at the end to returned the aggregated value.\n   * @param  {Stork~aggregateSuccess} [success]\n   *         The function to invoke when a value is successfully aggregated.\n   * @param  {Stork~aggregateSuccess} [failure]\n   *         The function to invoke if there's a problem.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  function aggregate(property, accumulate, getResult, promise)\n  {\n    var onSuccess = function(values, keys)\n    {\n      var returnedValue = undefined;\n\n      for (var i = 0; i < values.length; i++)\n      {\n        var v = values[ i ];\n\n        if (isObject( v ) && property in v)\n        {\n          accumulate( v[ property ] );\n        }\n      }\n\n      promise.$success( [ getResult() ] )\n    };\n    var onFailure = function(e)\n    {\n      promise.$failure( [e] );\n    };\n\n    this.all( onSuccess, onFailure );\n  }\n\n  /**\n   * Returns the number of values that are objects and have the specified \n   * property to the callback.\n   *\n   * This is part of the aggregation plugin.\n   *\n   * *Usage*\n   * ```javascript\n   * db.count('name', function(count) {\n   *   // count = the number of objects with the property 'name'\n   * });\n   * ```\n   * \n   * @memberOf Stork#\n   * @param  {String} property\n   *         The property on the object to look for.\n   * @param  {Stork~aggregateSuccess} [success]\n   *         The function to invoke with the number of values with the property.\n   * @param  {Stork~aggregateSuccess} [failure]\n   *         The function to invoke if there's a problem.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  function count(property, promise)\n  {\n    var total = 0;\n\n    var accumulate = function(v)\n    {\n      total++;\n    };\n    var getResult = function()\n    {\n      return total;\n    };\n\n    aggregate( property, accumulate, getResult, promise );\n  }\n\n  /**\n   * Returns the sum of a set of values taken from a property on all `Object` \n   * values to the callback.\n   *\n   * This is part of the aggregation plugin.\n   * \n   * *Usage*\n   * ```javascript\n   * db.sum('kills', function(sum) {\n   *   // sum = total of all kills\n   * });\n   * ```\n   * \n   * @memberOf Stork#\n   * @param  {String} property\n   *         The property on the object to sum.\n   * @param  {Stork~aggregateSuccess} [success]\n   *         The function to invoke with the sum.\n   * @param  {Stork~aggregateSuccess} [failure]\n   *         The function to invoke if there's a problem.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  function sum(property, promise)\n  {\n    var summing = 0;\n\n    var accumulate = function(v)\n    {\n      if (isNumber(v))\n      {\n        summing += v;\n      }\n    };\n    var getResult = function()\n    {\n      return summing;\n    };\n\n    aggregate( property, accumulate, getResult, promise );\n  }\n\n\n  /**\n   * Returns the average of a set of values taken from a property on all `Object` \n   * values to the callback.\n   *\n   * This is part of the aggregation plugin.\n   * \n   * *Usage*\n   * ```javascript\n   * db.avg('age', function(avg) {\n   *   // avg = the average age\n   * });\n   * ```\n   * \n   * @memberOf Stork#\n   * @param  {String} property\n   *         The property on the object to average.\n   * @param  {Stork~aggregateSuccess} [success]\n   *         The function to invoke with the average.\n   * @param  {Stork~aggregateSuccess} [failure]\n   *         The function to invoke if there's a problem.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  function avg(property, promise)\n  {\n    var summing = 0;\n    var total = 0;\n\n    var accumulate = function(v)\n    {\n      if (isNumber(v))\n      {\n        summing += v;\n        total++;\n      }\n    };\n    var getResult = function()\n    {\n      return summing / total;\n    };\n\n    aggregate( property, accumulate, getResult, promise );\n  }\n\n  /**\n   * Returns the minimum value of a set of values taken from a property on all \n   * `Object` values to the callback.\n   *\n   * This is part of the aggregation plugin.\n   * \n   * *Usage*\n   * ```javascript\n   * db.min('age', function(min) {\n   *   // min = the minimum age\n   * });\n   * ```\n   * \n   * @memberOf Stork#\n   * @param  {String} property\n   *         The property on the object to find the minimum value of.\n   * @param  {Stork~aggregateSuccess} [success]\n   *         The function to invoke with the minimum value.\n   * @param  {Stork~aggregateSuccess} [failure]\n   *         The function to invoke if there's a problem.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  function min(property, promise)\n  {\n    var minValue = Number.MAX_VALUE;\n\n    var accumulate = function(v)\n    {\n      if (isNumber(v))\n      {\n        minValue = Math.min( minValue, v );\n      }\n    };\n    var getResult = function()\n    {\n      return minValue;\n    };\n\n    aggregate( property, accumulate, getResult, promise );\n  }\n\n  /**\n   * Returns the maximum value of a set of values taken from a property on all \n   * `Object` values to the callback.\n   *\n   * This is part of the aggregation plugin.\n   * \n   * *Usage*\n   * ```javascript\n   * db.max('age', function(max) {\n   *   // max = the maximum age\n   * });\n   * ```\n   * \n   * @memberOf Stork#\n   * @param  {String} property\n   *         The property on the object to find the maximum value of.\n   * @param  {Stork~aggregateSuccess} [success]\n   *         The function to invoke with the maximum value.\n   * @param  {Stork~aggregateSuccess} [failure]\n   *         The function to invoke if there's a problem.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  function max(property, promise)\n  {\n    var maxValue = Number.MAX_VALUE;\n\n    var accumulate = function(v)\n    {\n      if (isNumber(v))\n      {\n        maxValue = Math.min( maxValue, v );\n      }\n    };\n    var getResult = function()\n    {\n      return maxValue;\n    };\n\n    aggregate( property, accumulate, getResult, promise );\n  }\n\n  var METHODS = \n  {\n    aggregate:  $promise( 'aggregate', aggregate ),\n    count:      $promise( 'count', count ),\n    sum:        $promise( 'sum', sum ),\n    avg:        $promise( 'avg', avg ),\n    min:        $promise( 'min', min ),\n    max:        $promise( 'max', max )\n  }; \n\n  return function(stork)\n  {\n    copy( METHODS, stork );\n  };\n\n})());\n\n\n  ","Stork.plugin((function()\n{\n\n  /**\n   * The format of the condition callback for {@link Stork#where}.\n   * \n   * @callback Stork~where\n   * @param {Any} value\n   *        The value to inspect and return true if you want it returned.\n   * @param {Any} key\n   *        The key to inspect and return true if you want it returned.\n   */\n  \n  /**\n   * The format of success callback for {@link Stork#where}.\n   * \n   * @callback Stork~whereSuccess\n   * @param {Array} values\n   *        The values matching the given condition.\n   * @param {Array} keys\n   *        The keys matching the given condition.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#where}.\n   * \n   * @callback Stork~whereFailure\n   * @param {Any} error \n   *        The error that was thrown.\n   */\n\n  /**\n   * Returns a subset of key-value pairs that match a condition function to the \n   * callback.\n   *\n   * This is part of the query plugin.\n   *\n   * *Usage*\n   * ```javascript\n   * var condition = function(value, key) {\n   *   // return true if key-value matches some condition\n   * };\n   * var onSuccessFunc = function(value, key) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(key, error) {\n   *   // uh oh!\n   * };\n   * db.where( condition, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.where( condition ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   *\n   * @memberOf Stork#\n   * @param  {Stork~where} condition\n   *         The function to invoke on each key-value pair to determine whether\n   *         that pair is included in the results.\n   * @param  {Stork~whereSuccess} [success]\n   *         The function to invoke with the matched key-value pairs.\n   * @param  {Stork~whereFailure} [failure]\n   *         The function to invoke if there was a problem retrieving the\n   *         key-value pairs.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  function where(condition, promise)\n  {\n    var onSuccess = function(values, keys)\n    {\n      var matchedKeys = [];\n      var matchedValues = [];\n\n      for (var i = 0; i < values.length; i++)\n      {\n        var v = values[ i ];\n        var k = keys[ i ];\n\n        if ( condition( v, k ) )\n        {\n          matchedValues.push( v );\n          matchedKeys.push( k );\n        }\n      }\n\n      promise.$success( [matchedValues, matchedKeys] );\n    };\n    var onFailure = function(e)\n    {\n      promise.$failure( [e] );\n    };\n\n    this.all( onSuccess, onFailure );\n  }\n\n  /**\n   * The format of success callback for {@link Stork#select}.\n   * \n   * @callback Stork~selectSuccess\n   * @param {Array} values\n   *        If columns is a string this is an array of values pulled from the\n   *        same property on all values that are objects. If columns is an array\n   *        this is an array of objects containing the properties that exist\n   *        in the columns array.\n   * @param {Array} keys\n   *        An array of the keys for pointing to the original values.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#select}.\n   * \n   * @callback Stork~selectFailure\n   * @param {String|Array} columns\n   *        The property you wanted to return or an array of properties to return.\n   * @param {Any} error \n   *        The error that was thrown.\n   */\n  \n  /**\n   * Returns column values (if columns is a string) or an array of objects of \n   * column values (if columns is an array) to the callback.\n   *\n   * This is part of the query plugin.\n   *\n   * *Usage*\n   * ```javascript\n   * var onSuccessFunc = function(values, keys) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(columns, error) {\n   *   // uh oh!\n   * };\n   * db.select( 'name', onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.select( ['name', 'id'] ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   *\n   * @memberOf Stork#\n   * @param  {String|Array} columns\n   *         The property you want to return or an array of properties to return.\n   * @param  {Stork~selectSuccess} [success]\n   *         The function to invoke with the selected properties.\n   * @param  {Stork~selectFailure} [failure]\n   *         The function to invoke if there was a problem selecting the columns.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  function select(columns, promise)\n  {\n    var onSuccess = function(values, keys)\n    {\n      var results = [];\n      var resultKeys = [];\n\n      for (var i = 0; i < values.length; i++)\n      {\n        var v = values[ i ];\n\n        if ( isObject( v ) )\n        {\n          if ( isString( columns ) )\n          {\n            if ( columns in v )\n            {\n              results.push( v[ columns ] );\n              resultKeys.push( keys[ i ] );\n            }\n          }\n          else if ( isArray( columns ) )\n          {\n            var resultObject = {};\n            var resultColumns = 0;\n\n            for (var k = 0; k < columns.length; k++)\n            {\n              var c = columns[ k ];\n\n              if ( c in v )\n              {\n                resultObject[ c ] = v[ c ];\n                resultColumns++;\n              }\n            }\n\n            if ( resultColumns > 0 )\n            {\n              results.push( resultObject );\n              resultKeys.push( keys[ i ] );\n            }\n          }\n        }\n      }\n\n      promise.$success( [results, resultKeys] );\n    };\n    var onFailure = function(e)\n    {\n      promise.$failure( [columns, e] );\n    };\n\n    this.all( onSuccess, onFailure );\n  }\n\n  /**\n   * The format of the comparater for {@link Stork#sort}.\n   *\n   * @callback Stork~sortComparator\n   * @param {Any} a\n   *        The first value to compare.\n   * @param {Any} b\n   *        The second value to compare.\n   * @return {Number} -\n   *         A negative number if `a < b`, a positive number of `a > b` and 0\n   *         if `a == b`.\n   */\n\n  /**\n   * The format of success callback for {@link Stork#sort}.\n   * \n   * @callback Stork~sortSuccess\n   * @param {Array} values\n   *        The array of sorted values.\n   * @param {Array} keys\n   *        The array of sorted keys.\n   */\n\n  /**\n   * The format of failure callback for {@link Stork#sort}.\n   * \n   * @callback Stork~sortFailure\n   * @param {Any} error \n   *        The error that was thrown.\n   */\n  \n  /**\n   * Sorts all key-value pairs and returns them to the callback. Next time the\n   * key-value pairs are iterated over they will be returned in the same order.\n   * The underlying structure should be considered unsorted anytime key-value\n   * pairs are updated, added, or removed.\n   *\n   * This is part of the query plugin.\n   *\n   * *Usage*\n   * ```javascript\n   * var compareFunc = function(a, b) {\n   *   // compare a & b and return a number\n   * };\n   * var onSuccessFunc = function(values, keys) {\n   *   // handle success\n   * };\n   * var onFailureFunc = function(error) {\n   *   // uh oh!\n   * };\n   * db.sort( compareFunc, false, onSucessFunc, onFailureFunc ); // listen for success/failure\n   * db.sort( compareFunc ).then( onSuccessFunc, onFailureFunc ); // listen to promise\n   * ```\n   *\n   * @memberOf Stork#\n   * @param  {Stork~sortComparator} comparator\n   *         The function used to compare two values.\n   * @param  {Boolean} desc\n   *         If the key-value pairs should be in descending (reversed) order.\n   * @param  {Stork~sortSuccess} [success]\n   *         The function to invoke with the sorted values & keys.\n   * @param  {Stork~sortFailure} [failure]\n   *         The function to invoke if there was a problem sorting the pairs.\n   * @return {Stork.Promise} -\n   *         The promise that can be used to listen for success or failure, as\n   *         well as chaining additional calls.\n   */\n  function sort(comparator, desc, promise)\n  {\n    var onSuccess = function()\n    {\n      var cache = this.cache;\n\n      cache.sort( comparator );\n\n      if ( desc )\n      {\n        cache.reverse();\n      }\n\n      promise.$success( [cache.values, cache.okeys] );\n    };\n    var onFailure = function(e)\n    {\n      promise.$failure( [e] );\n    };\n\n    this.all( onSuccess, onFailure );\n  }\n\n  var METHODS = \n  {\n    where:  $promise( 'where', where ),\n    select: $promise( 'select', select ),\n    sort:   $promise( 'sort', sort )\n  }; \n\n  return function(stork)\n  {\n    copy( METHODS, stork );\n  };\n\n})());\n\n\n  ","\nStork.adapter('chrome-storage-local', 4, function()\n{\n  var store = window.chrome && chrome.storage ? chrome.storage.local : false;\n\n  function isError()\n  {\n    return chrome && chrome.runtime && chrome.runtime.lastError;\n  };\n\n  return {\n\n    encode: function(key)\n    {\n      return this.prefix + toJson( key );\n    },\n\n    decode: function(rawKey)\n    {\n      return fromJson( rawKey.substring( this.prefix.length ) );\n    },\n\n    valid: function()\n    {\n      if (!store)\n      {\n        return false;\n      }\n\n      try\n      {\n        var temp = Math.random();\n        var map = {};\n\n        map[ temp ] = temp;\n        store.set( map );\n        store.remove( temp );\n\n        return true;\n      }\n      catch (e)\n      {\n        return false;\n      }\n    },\n\n    init: function(options, success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n\n      this.prefix = coalesce( options.prefix, this.name + '-' );\n\n      if ( this.lazy )\n      {\n        this._finishInitialization( promise, [this] );\n      }\n      else\n      {\n        promise.$bindTo( this.reload(), [this] );\n      }\n\n      return promise;\n    },\n\n    reload: function(success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n      var stork = this;\n      var prefix = this.prefix;\n      var cache = new FastMap();\n\n      store.get( null, function(items)\n      {\n        if ( isError() )\n        {\n          promise.$failure( [isError()] );\n        }\n        else\n        {\n          for (var rawKey in items)\n          {\n            if ( rawKey.substring( 0, prefix.length ) === prefix )\n            {\n              cache.put( rawKey, items[ rawKey ], stork.decode( rawKey ) );\n            }\n          }\n\n          stork.cache.overwrite( cache );\n          stork.loaded = true;\n\n          stork.finishReload( promise );\n        }\n\n      });\n\n      return promise;\n    },\n\n    _get: function(key, rawKey, promise)\n    {\n      var stork = this;\n\n      store.get( rawKey, function(items)\n      {\n        if ( isError() )\n        {\n          promise.$failure( [key, isError()] );\n        }\n        else\n        {\n          if ( items.length )\n          {\n            var value = fromJson( items[0] );\n\n            stork.cache.put( rawKey, value, key );\n\n            promise.$success( [value, key] );\n          }\n          else\n          {\n            promise.$success( [undefined, key] );\n          }\n        }\n      });\n    },\n\n    _destroy: function(promise)\n    {\n      var stork = this;\n      var removeByKeys = function()\n      {\n        store.remove( this.cache.keys, function()\n        {\n          if ( isError() )\n          {\n            promise.$failure( [isError()] );\n          }\n          else\n          {\n            stork.cache.reset();\n\n            promise.$success();\n          }\n        });\n      };\n      var onFailure = function(e)\n      {\n        promise.$failure( [e] );\n      };\n\n      if ( this.loaded )\n      {\n        removeByKeys();\n      }\n      else\n      {\n        this.reload( removeByKeys, onFailure );\n      }\n    },\n\n    _resetPromise: function(keys, values, success, failure)\n    {\n      return new Promise( this, success, failure );\n    },\n\n    _reset: function(keys, values, rawKeys, rawValues, promise)\n    {\n      var stork = this;\n\n      var setFailure = function(e)\n      {\n        promise.$failure( [keys, values, e] );\n      };\n      var onDestroyed = function()\n      {\n        var obj = {};\n\n        for (var i = 0; i < values.length; i++)\n        {\n          obj[ rawKeys[ i ] ] = values[ i ];\n        }\n\n        store.set( obj, function()\n        {\n          if ( isError() )\n          {\n            setFailure( isError() );\n          }\n          else\n          {\n            for (var i = 0; i < values.length; i++)\n            {\n              stork.cache.put( rawKeys[ i ], values[ i ], keys[ i ] );\n            }\n\n            promise.$success( [keys, values] );\n          }\n        });\n      };\n\n      this._destroy( new Promise( this, onDestroyed, setFailure ) );\n    },\n\n    _put: function(key, value, rawKey, rawValue, promise)\n    {\n      var stork = this;\n      var obj = {};\n\n      obj[ rawKey ] = value;\n\n      store.set( obj, function()\n      {\n        if ( isError() )\n        {\n          promise.$failure( [key, value, isError()] );\n        }\n        else\n        {\n          var previousValue = stork.cache.get( rawKey );\n\n          stork.cache.put( rawKey, value, key );\n\n          promise.$success( [key, value, previousValue] );\n        }\n      });\n    },\n\n    _remove: function(key, rawKey, value, promise)\n    {\n      var stork = this;\n\n      store.remove( rawKey, function()\n      {\n        if ( isError() )\n        {\n          promise.$failure( [key, isError()] );\n        }\n        else\n        {\n          stork.cache.remove( rawKey );\n\n          promise.$success( [value, key] );\n        }\n      });\n    },\n\n    _size: function(promise)\n    {\n      var onSuccess = function(keys, values)\n      {\n        promise.$success( [keys.length] );\n      };\n      var onFailure = function(e)\n      {\n        promise.$failure( [e] );\n      };\n\n      this.reload( onSuccess, onFailure );\n    }\n\n  }\n});\n","\nStork.adapter('ie-userdata', 1.5, \n{\n  valid: function() \n  {\n    return def( document.body.addBehavior );\n  },\n\n  init: function(options, success, failure) \n  {\n    var promise = new Promise( this, success, failure );\n\n    var s = document.createElement('span');\n    s.style.behavior = \"url('#default#userData')\";\n    s.style.position = 'absolute';\n    s.style.left = 10000;\n    document.body.appendChild(s);\n\n    this.store = s;\n    this.store.load( this.name );\n\n    if ( this.lazy )\n    {\n      this.finishInitialization( promise, [this] );\n    }\n    else\n    {\n      promise.$bindTo( this.reload(), [this] );\n    }\n    \n    return promise;\n  },\n\n  reload: function(success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    var attributes = this.store.XMLDocument.firstChild.attributes;\n    var cache = new FastMap();\n\n    for (var i = 0; i < attributes.length; i++) \n    {\n      try\n      {\n        var v = attributes[ i ];\n        var rawKey = v.nodeName;\n        var rawValue = v.nodeValue;\n        var key = this.decode( rawKey );\n        var value = fromJson( rawValue );\n\n        cache.put( rawKey, value, key ); \n      }\n      catch (e) \n      {\n        // ignore\n      }\n    }\n\n    this.cache.overwrite( cache );\n    this.loaded = true;\n    this.finishReload( promise );\n\n    return promise;\n  },\n\n  _get: function(key, rawKey, promise)\n  {\n    var rawValue = this.store.getAttribute( rawKey );\n\n    if ( rawValue === null )\n    {\n      promise.$success( [undefined, key] );\n    }\n    else\n    {\n      var value = null;\n\n      try\n      {\n        value = fromJson( rawValue );\n      }\n      catch (e)\n      {\n        promise.$failure( [e] );\n      }\n\n      if ( promise.$pending() )\n      {\n        this.cache.put( rawKey, value, key );\n\n        promise.$success( [value, key] );\n      }\n    }\n  },\n\n  _destroy: function(promise)\n  {\n    var attributes = this.store.XMLDocument.firstChild.attributes;\n\n    for (var i = 0; i < attributes.length; i++) \n    {\n      this.store.removeAttribute( attributes[ i ].nodeName );\n    }\n\n    this.cache.reset();\n\n    promise.$success();\n  },\n\n  _put: function(key, value, rawKey, rawValue, promise)\n  {\n    var previousValue = this.cache.get( rawKey );\n\n    try\n    {\n      this.store.setAttribute( rawKey, rawValue );\n    }\n    catch (e)\n    {\n      promise.$failure( [key, value, e] );\n    }\n\n    if ( promise.$pending() )\n    {\n      this.cache.put( rawKey, value, key );\n\n      promise.$success( [key, value, previousValue] );\n    }\n  },\n\n  _remove: function(key, rawKey, value, promise)\n  {\n    this.store.removeAttribute( rawKey );\n    this.cache.remove( rawKey );\n\n    promise.$success( [value, key] );\n  }\n\n});","Stork.adapter('indexed-db', 5, function()\n{\n\n  var getIDB = function() \n  {\n    return window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.oIndexedDB || window.msIndexedDB;\n  };\n\n  var getIDBTransaction = function() \n  {\n    return window.IDBTransaction || window.webkitIDBTransaction || window.mozIDBTransaction || window.oIDBTransaction || window.msIDBTransaction;\n  };\n\n  var getIDBKeyRange = function() \n  {\n    return window.IDBKeyRange || window.webkitIDBKeyRange || window.mozIDBKeyRange || window.oIDBKeyRange || window.msIDBKeyRange;\n  };\n\n  var DATABASE_NAME = 'stork';\n  var DATABASE_VERSION = 3;\n  var READ_WRITE = (getIDBTransaction() && 'READ_WRITE' in getIDBTransaction()) ? getIDBTransaction().READ_WRITE : 'readwrite';\n\n  return {\n\n    valid: function() \n    {\n      return !!getIDB();\n    },\n\n    init: function(options, success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n\n      var stork = this;\n      var factory = getIDB();\n      var request = factory.open( this.name, DATABASE_VERSION );\n\n      request.onerror = function(e)\n      {\n        promise.$failure( [e] );\n      };\n\n      // First started or it needs a version upgrade\n      request.onupgradeneeded = function()\n      {\n        stork.db = request.result;\n        stork.db.createObjectStore( stork.name, { keyPath: this.key } );\n      };\n\n      // Database is ready for use\n      request.onsuccess = function(event)\n      {\n        stork.db = request.result;\n\n        if ( stork.lazy )\n        {\n          stork.finishInitialization( promise, [stork] );\n        }\n        else\n        {\n          promise.$bindTo( stork.reload(), [stork] );\n        }\n      };\n\n      return promise;\n    },\n\n    reload: function(success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n\n      var stork = this;\n      var objectStore = this.db.transaction( this.name ).objectStore( this.name );\n      var cursor = objectStore.openCursor();\n      var cache = new FastMap();\n\n      cursor.onsuccess = function(e)\n      {\n        var result = cursor.result;\n\n        if (result)\n        {\n          var rawKey = result.key;\n          var value = result.value;\n          var key = stork.decode( rawKey );\n\n          cache.put( rawKey, value, key );\n\n          result['continue']();\n        }\n        else\n        {\n          stork.cache.overwrite( cache );\n          stork.loaded = true;\n          stork.finishReload( promise, [stork.cache.values, stork.cache.okeys] );\n        }\n      };\n\n      cursor.onerror = function(e)\n      {\n        promise.$failure( [keys, e] );\n      };\n\n      return promise;\n    },\n\n    _destroy: function(promise)\n    {\n      var stork = this;\n      var objectStore = this.db.transaction( this.name, READ_WRITE ).objectStore( this.name );\n\n      objectStore.transaction.oncomplete = function()\n      {\n        stork.cache.reset();\n\n        promise.$success();\n      };\n\n      objectStore.transaction.onabort = function(e)\n      {\n        promise.$failure( [e] );\n      };\n\n      objectStore.clear();\n    },\n\n    _get: function(key, rawKey, promise)\n    {\n      var stork = this;\n      var objectStore = this.db.transaction( this.name ).objectStore( this.name );\n      var request = objectStore.get( rawKey );\n\n      request.onsuccess = function(e)\n      {\n        if ( request.result === undefined )\n        {\n          promise.$success( [undefined, key] );\n        }\n        else\n        {\n          var value = request.result;\n\n          stork.cache.put( rawKey, value, key );\n\n          promise.$success( [value, key] );          \n        }\n      };\n\n      request.onerror = function()\n      {\n        promise.$failure( [key, request.error] );\n      };\n    },\n\n    _put: function(key, value, rawKey, rawValue, promise)\n    {\n      var stork = this;\n      var objectStore = this.db.transaction( this.name, READ_WRITE ).objectStore( this.name );\n\n      objectStore.transaction.oncomplete = function()\n      {\n        var previousValue = stork.cache.get( rawKey );\n\n        stork.cache.put( rawKey, value, key );\n\n        promise.$success( [key, value, previousValue] );\n      }; \n\n      objectStore.transaction.onabort = function(e)\n      {\n        promise.$failure( [key, value, e] );\n      };\n\n      objectStore.put( value, rawKey );\n    },\n\n    _remove: function(key, rawKey, value, promise)\n    {  \n      var stork = this;\n      var objectStore = this.db.transaction( this.name, READ_WRITE ).objectStore( this.name );\n\n      objectStore.transaction.oncomplete = function()\n      {\n        stork.cache.remove( rawKey );\n\n        promise.$success( [value, key] );\n      }; \n\n      objectStore.transaction.onabort = function(e)\n      {\n        promise.$failure( [key, e] );\n      };\n\n      objectStore['delete']( rawKey );\n    },\n\n    _size: function(promise)\n    {\n      var stork = this;\n      var objectStore = this.db.transaction( this.name, READ_WRITE ).objectStore( this.name );\n      var request = objectStore.count();\n\n      request.onsuccess = function()\n      {\n        promise.$success( [request.result] );\n      };\n\n      request.onerror = function(e)\n      {\n        promise.$failure( [request.error] );\n      };\n    }\n\n    // TODO getMany, removeMany\n\n  };\n\n});","\nStork.adapter('local-storage', 3, function()\n{\n  var store = window.localStorage;\n\n  return {\n\n    encode: function(key)\n    {\n      return this.prefix + toJson( key );\n    },\n\n    decode: function(rawKey)\n    {\n      return fromJson( rawKey.substring( this.prefix.length ) );\n    },\n\n    valid: function()\n    {\n      if (!store) \n      {\n        return false;\n      }\n      try \n      {\n        var temp = Math.random();\n        store.setItem( temp, temp );\n        store.removeItem( temp );\n\n        return true;\n      } \n      catch (e) \n      {\n        return false;\n      }\n    },\n\n    init: function(options, success, failure) \n    {\n      var promise = new Promise( this, success, failure );\n\n      this.prefix = coalesce( options.prefix, this.name + '-' );\n\n      if ( this.lazy )\n      {\n        this.finishInitialization( promise, [this] );\n      }\n      else\n      {\n        promise.$bindTo( this.reload(), [this] );\n      }\n\n      return promise;\n    },\n\n    reload: function(success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n      var prefix = this.prefix;\n      var cache = new FastMap();\n\n      try\n      {\n        for (var i = 0; i < store.length; i++)\n        {\n          var rawKey = store.key( i );\n\n          if ( rawKey.substring( 0, prefix.length ) === prefix )\n          {\n            var rawValue = store.getItem( rawKey );\n            var value = fromJson( rawValue );\n            var key = this.decode( rawKey );\n\n            cache.put( rawKey, value, key );\n          }  \n        }\n\n        this.cache.overwrite( cache );\n        this.loaded = true;\n      }\n      catch (e)\n      {\n        promise.$failure( [e] );\n      }\n\n      this.finishReload( promise );\n\n      return promise;\n    },\n\n    _destroy: function(promise)\n    {\n      var stork = this;\n      var prefix = this.prefix;\n      var removeByKeys = function( keys )\n      {\n        try\n        {\n          for (var i = 0; i < keys.length; i++)\n          {\n            store.removeItem( keys[ i ] );\n          }\n        }\n        catch (e)\n        {\n          promise.$failure( [e] );\n        }\n\n        if ( promise.$pending() )\n        {\n          stork.cache.reset();\n\n          promise.$success();\n        }\n      };\n      \n      if ( this.loaded )\n      {\n        removeByKeys( this.cache.keys );\n      }\n      else\n      {\n        var keys = [];\n\n        try\n        {\n          for (var i = 0; i < store.length; i++)\n          {\n            var rawKey = store.key( i );\n\n            if ( rawKey.substring( 0, prefix.length ) === prefix )\n            {\n              keys.push( rawKey );\n            }\n          }  \n        }\n        catch (e)\n        {\n          promise.$failure( [e] );\n        }\n\n        if ( promise.$pending() )\n        {\n          removeByKeys( keys );          \n        }\n      }\n    },\n\n    _get: function(key, rawKey, promise)\n    {\n      try\n      { \n        var rawValue = store.getItem( rawKey );\n\n        if ( rawValue === null )\n        {\n          promise.$success( [undefined, key] );\n        }\n        else\n        {\n          var value = fromJson( rawValue );\n\n          this.cache.put( rawKey, value, key );\n\n          promise.$success( [value, key] ); \n        }\n      }\n      catch (e)\n      {\n        promise.$failure( [key, e] );\n      }\n    },\n\n    _put: function(key, value, rawKey, rawValue, promise)\n    {\n      try\n      {\n        store.setItem( rawKey, rawValue );        \n      }\n      catch (e)\n      {\n        promise.$failure( [key, value, e] );\n      }\n\n      if ( promise.$pending() )\n      {\n        var previousValue = this.cache.get( rawKey );\n\n        this.cache.put( rawKey, value, key );\n\n        promise.$success( [key, value, previousValue] );\n      }\n    },\n\n    _remove: function(key, rawKey, value, promise)\n    {\n      try\n      {\n        store.removeItem( rawKey );\n      }\n      catch (e)\n      {\n        promise.$failure( [key, e] );\n      }\n\n      if ( promise.$pending() )\n      {\n        this.cache.remove( rawKey );\n\n        promise.$success( [value, key] );\n      }\n    },\n\n    _size: function(promise)\n    {\n      var onSuccess = function(keys, values)\n      {\n        promise.$success( [keys.length] );\n      };\n      var onFailure = function(e)\n      {\n        promise.$failure( [e] );\n      };\n\n      this.reload( onSuccess, onFailure );\n    }\n\n  }\n});","\nStork.adapter('memory', 1, \n{\n  valid: function() \n  {\n    return true;\n  },\n\n  init: function(options, success, failure) \n  {\n    var promise = new Promise( this, success, failure );\n\n    this.loaded = true;\n    this.finishInitialization( promise, [this] );\n    \n    return promise;\n  },\n\n  reload: function(success, failure)\n  {\n    var promise = new Promise( this, success, failure );\n\n    this.finishReload( promise );\n\n    return promise;\n  },\n\n  _destroy: function(promise)\n  {\n    this.cache.reset();\n\n    promise.$success();\n  },\n\n  _put: function(key, value, rawKey, rawValue, promise)\n  {\n    var previousValue = this.cache.get( rawKey );\n\n    this.cache.put( rawKey, value, key );\n\n    promise.$success( [key, value, previousValue] );\n  },\n\n  _remove: function(key, rawKey, value, promise)\n  {\n    this.cache.remove( rawKey );\n\n    promise.$success( [value, key] );\n  }\n\n});","\nStork.adapter('webkit-sqlite', 6, function()\n{\n  var DATABASE_NAME = 'stork';\n\n  var SQL_CREATE = 'CREATE TABLE IF NOT EXISTS \"{0}\" (\"id\" TEXT PRIMARY KEY, \"value\" TEXT)';\n  var SQL_SELECT  = 'SELECT \"value\" FROM \"{0}\" WHERE \"id\" = ?';\n  var SQL_SELECT_ALL = 'SELECT \"id\", \"value\" FROM \"{0}\"';\n  var SQL_SELECT_MANY = 'SELECT \"id\", \"value\" FROM \"{0}\" WHERE \"id\" IN ({1})';\n  var SQL_INSERT = 'INSERT OR REPLACE INTO \"{0}\" (\"id\", \"value\") VALUES (?, ?)';\n  var SQL_DELETE = 'DELETE FROM \"{0}\" WHERE \"id\" = ?';\n  var SQL_COUNT = 'SELECT COUNT(*) as \"count\" FROM \"{0}\"';\n  var SQL_DESTROY = 'DELETE FROM \"{0}\"';\n  var SQL_DELETE_MANY = 'DELETE FROM \"{0}\" WHERE \"id\" IN ({1})';\n\n  function streplace(str, arr)\n  {\n    return str.replace(/\\{(\\d+)\\}/g, function(match, index)\n    {\n      index = parseInt( index );\n\n      if ( isNaN( index ) || index < 0 || index >= arr.length )\n      {\n        return match;\n      }\n\n      return arr[ index ];\n    });\n  }\n\n  return {\n\n    valid: function()\n    {\n      return !!window.openDatabase;\n    },\n\n    init: function(options, success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n\n      var databaseName = coalesce( options.database, DATABASE_NAME );\n      var databaseSize = coalesce( options.size, 65536 );\n      var databaseVersion = coalesce( options.version, '1.0' );\n\n      var stork = this;\n\n      var onFailure = function(tx, error)\n      {\n        promise.$failure( [error] );\n      };\n      var onTransactionForCreate = function(tx)\n      {\n        tx.executeSql( stork.SQL_CREATE, [], onCreate, onFailure );\n      };\n      var onCreate = function(tx, results)\n      {\n        if ( stork.lazy )\n        {\n          stork.finishInitialization( promise, [stork] );\n        }\n        else\n        {\n          promise.$bindTo( stork.reload(), [stork] );\n        }\n      };\n\n      this.SQL_CREATE     = streplace( SQL_CREATE, [this.name] );\n      this.SQL_SELECT     = streplace( SQL_SELECT, [this.name] );\n      this.SQL_SELECT_ALL = streplace( SQL_SELECT_ALL, [this.name] );\n      this.SQL_INSERT     = streplace( SQL_INSERT, [this.name] );\n      this.SQL_DELETE     = streplace( SQL_DELETE, [this.name] );\n      this.SQL_DESTROY    = streplace( SQL_DESTROY, [this.name] );\n      this.SQL_COUNT      = streplace( SQL_COUNT, [this.name] );\n\n      this.db = openDatabase( databaseName, databaseVersion, databaseName, databaseSize );\n      this.db.transaction( onTransactionForCreate, onFailure );\n\n      return promise;\n    },\n\n    reload: function(success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n      var stork = this;\n\n      var onFailure = function(tx, error)\n      {\n        promise.$failure( [error] );\n      };\n      var onTransactionForSelect = function(tx)\n      {\n        tx.executeSql( stork.SQL_SELECT_ALL, [], onResults, onFailure );\n      };\n      var onResults = function(tx, results)\n      {\n        var cache = new FastMap();\n        try\n        {\n          for (var i = 0; i < results.rows.length; i++)\n          {\n            var record = results.rows[ i ];\n            var value = fromJson( record.value );\n            var key = fromJson( record.id );\n\n            cache.put( record.id, value, key );\n          }\n\n          stork.cache.overwrite( cache );\n          stork.loaded = true;\n        }\n        catch (e)\n        {\n          promise.$failure( [e] );\n        }\n\n        stork.finishReload( promise );\n      };\n\n      this.db.readTransaction( onTransactionForSelect, onFailure );\n\n      return promise;\n    },\n\n    _get: function(key, rawKey, promise)\n    {\n      var stork = this;\n\n      var onFailure = function(tx, error)\n      {\n        promise.$failure( [key, error] );\n      };\n      var onTransaction = function(tx)\n      {\n        tx.executeSql( stork.SQL_SELECT, [rawKey], onResult, onFailure );\n      };\n      var onResult = function(tx, results)\n      {\n        var value = undefined;\n        try\n        {\n          var first = results.rows[ 0 ];\n\n          if ( first && first.value !== undefined )\n          {\n            value = fromJson( first.value );\n          }\n        }\n        catch (e)\n        {\n          promise.$failure( [key, e] );\n        }\n\n        if ( promise.$pending() )\n        {\n          if ( value !== undefined )\n          {\n            stork.cache.put( rawKey, value, key );\n\n            promise.$success( [value, key] );\n          }\n          else\n          {\n            promise.$success( [undefined, key] );\n          }\n        }\n      };\n\n      this.db.readTransaction( onTransaction, onFailure );\n    },\n\n    _destroy: function(promise)\n    {\n      var stork = this;\n\n      var onTransaction = function(tx)\n      {\n        tx.executeSql( stork.SQL_DESTROY, [], onSuccess, onFailure );\n      };\n      var onSuccess = function(tx, results)\n      {\n        stork.cache.reset();\n\n        promise.$success();\n      };\n      var onFailure = function(tx, error)\n      {\n        promise.$failure( [error] );\n      };\n\n      this.db.transaction( onTransaction, onFailure );\n    },\n\n    _put: function(key, value, rawKey, rawValue, promise)\n    {\n      var stork = this;\n\n      var onTransaction = function(tx)\n      {\n        tx.executeSql( stork.SQL_INSERT, [rawKey, rawValue], onSuccess, onFailure );\n      };\n      var onSuccess = function(tx, results)\n      {\n        var previousValue = stork.cache.get( rawKey );\n\n        stork.cache.put( rawKey, value, key );\n\n        promise.$success( [key, value, previousValue] );\n      };\n      var onFailure = function(tx, error)\n      {\n        promise.$failure( [key, value, error] );\n      };\n\n      this.db.transaction( onTransaction, onFailure );\n    },\n\n    _remove: function(key, rawKey, value, promise)\n    {\n      var stork = this;\n\n      var onTransaction = function(tx)\n      {\n        tx.executeSql( stork.SQL_DELETE, [rawKey], onSuccess, onFailure );\n      };\n      var onSuccess = function(tx, results)\n      {\n        stork.cache.remove( rawKey );\n\n        promise.$success( [value, key] );\n      };\n      var onFailure = function(tx, error)\n      {\n        promise.$failure( [key, error] );\n      };\n\n      this.db.transaction( onTransaction, onFailure );\n    },\n\n    _size: function(promise)\n    {\n      var stork = this;\n\n      var onFailure = function(tx, error)\n      {\n        promise.$failure( [error] );\n      };\n      var onTransaction = function(tx)\n      {\n        tx.executeSql( stork.SQL_COUNT, [], onCount, onFailure );\n      };\n      var onCount = function(tx, results)\n      {\n        promise.$success( [results.rows[0].count] );\n      };\n\n      this.db.readTransaction( onTransaction, onFailure );\n    },\n\n    _resetPromise: function(keys, values, success, failure)\n    {\n      return Promise.Group( values.length + 1, this, success, failure );\n    },\n\n    _reset: function(keys, values, rawKeys, rawValues, promise)\n    {\n      var stork = this;\n\n      var onTransaction = function(tx)\n      {\n        tx.executeSql( stork.SQL_DESTROY, [], onSuccess( -1 ), onFailure );\n\n        for (var i = 0; i < rawValues.length; i++)\n        {\n          tx.executeSql( stork.SQL_INSERT, [rawKeys[ i ], rawValues[ i ]], onSuccess( i ), onFailure );\n        }\n      };\n      var onSuccess = function(i)\n      {\n        return function()\n        {\n          if (i !== -1)\n          {\n            stork.cache.put( rawKeys[ i ], values[ i ], keys[ i ] );\n          }\n\n          promise.$success( [keys, values] );\n        };\n      };\n      var onFailure = function(tx, error)\n      {\n        promise.$failure( [keys, values, error] );\n      };\n\n      stork.cache.reset();\n\n      this.db.transaction( onTransaction, onFailure );\n    },\n\n    batch: function(records, success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n\n      if ( this.handlePending( this.batch, arguments, promise ) )\n      {\n        return promise;\n      }\n\n      var stork = this;\n      var keyName = this.key;\n      var successful = 0;\n      var converted = [];\n\n      try\n      {\n        for (var i = 0; i < records.length; i++)\n        {\n          var value = records[ i ];\n          var key = value[ keyName ];\n\n          if ( undef(key) )\n          {\n            key = value[ keyName ] = uuid();\n          }\n\n          converted.push(\n          {\n            value: value,\n            key: key,\n            rawKey: toJson( key ),\n            rawValue: toJson( value )\n          });\n        }\n      }\n      catch (e)\n      {\n        promise.$failure( [records, successful, e] );\n\n        return promise;\n      }\n\n      var onTransaction = function(tx)\n      {\n        for (var i = 0; i < converted.length; i++)\n        {\n          var record = converted[ i ];\n\n          tx.executeSql( stork.SQL_INSERT, [record.rawKey, record.rawValue], onSuccess, onFailure );\n        }\n      };\n      var onSuccess = function(tx, results)\n      {\n        if ( ++successful === records.length && promise.$pending() )\n        {\n          for (var i = 0; i < converted.length; i++)\n          {\n            var record = converted[ i ];\n\n            stork.cache.put( record.rawKey, record.value, record.key );\n          }\n\n          promise.$success( [records] );\n        }\n      };\n      var onFailure = function(tx, error)\n      {\n        promise.$failure( [records, successful, error] );\n      };\n\n      this.db.transaction( onTransaction, onFailure );\n\n      return promise;\n    },\n\n    removeMany: function(keys, success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n\n      if ( this.handlePending( this.removeMany, arguments, promise ) )\n      {\n        return promise;\n      }\n\n      var stork = this;\n      var rawKeys = [];\n      var values = [];\n      var binder = [];\n      var query = '';\n\n      var onTransaction = function(tx)\n      {\n        tx.executeSql( query, rawKeys, onSuccess, onFailure );\n      };\n      var onSuccess = function(tx, results)\n      {\n        for (var i = 0; i < rawKeys.length; i++)\n        {\n          stork.cache.remove( rawKeys[ i ] );\n        }\n\n        promise.$success( [values, keys] );\n      };\n      var onFailure = function(tx, error)\n      {\n        promise.$failure( [values, 0, error] );\n      };\n\n      try\n      {\n        for (var i = 0; i < keys.length; i++)\n        {\n          var key = toJson( keys[ i ] );\n\n          if ( this.cache.has( key ) )\n          {\n            rawKeys[ i ] = key;\n            values[ i ] = this.cache.get( key );\n            binder[ i ] = '?';\n          }\n        }\n\n        query = streplace( SQL_DELETE_MANY, [this.name, binder.join(',')] );\n      }\n      catch (e)\n      {\n        promise.$failure( [values, e] );\n      }\n\n      if ( promise.$pending() )\n      {\n        this.db.transaction( onTransaction, onFailure );\n      }\n\n      return promise;\n    },\n\n    getMany: function(keys, success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n\n      if ( this.handlePending( this.removeMany, arguments, promise ) )\n      {\n        return promise;\n      }\n\n      var stork = this;\n      var rawKeys = [];\n      var keyToValueIndex = [];\n      var values = [];\n      var binder = [];\n      var query = '';\n\n      var onTransaction = function(tx)\n      {\n        tx.executeSql( query, rawKeys, onSuccess, onFailure );\n      };\n      var onSuccess = function(tx, results)\n      {\n        for (var i = 0; i < results.rows.length; i++)\n        {\n          var r = results.rows[ i ];\n\n          for (var k = 0; k < rawKeys.length; k++)\n          {\n            if ( rawKeys[ k ] === r.id )\n            {\n              var value = fromJson( r.value );\n              var index = keyToValueIndex[ k ];\n\n              values[ index ] = value;\n              stork.cache.put( r.id, value, keys[ index ] );\n            }\n          }\n        }\n\n        promise.$success( [values, keys] );\n      };\n      var onFailure = function(tx, error)\n      {\n        promise.$failure( [keys, error] );\n      };\n\n      try\n      {\n        for (var i = 0; i < keys.length; i++)\n        {\n          var key = toJson( keys[ i ] );\n\n          if ( this.cache.has( key ) )\n          {\n            values[ i ] = this.cache.get( key );\n          }\n          else\n          {\n            rawKeys.push( key );\n            keyToValueIndex.push( i );\n            binder.push( '?' );\n          }\n        }\n\n        query = streplace( SQL_SELECT_MANY, [this.name, binder.join(',')] );\n      }\n      catch (e)\n      {\n        promise.$failure( [values, e] );\n      }\n\n      if ( promise.$pending() )\n      {\n        if ( rawKeys.length )\n        {\n          this.db.transaction( onTransaction, onFailure );\n        }\n        else\n        {\n          promise.$success( [values, keys] );\n        }\n      }\n\n      return promise;\n    }\n\n  }\n});\n","\nStork.adapter('window-name', 2, function()\n{\n\n  function loadData()\n  {\n    if ( !loadData.cache )\n    {\n      try\n      {\n        loadData.cache = fromJson( window.top.name );\n      }\n      catch (e)\n      {\n        loadData.cache = {};\n      }\n    }\n    \n    return loadData.cache;\n  }\n\n  function saveData()\n  {\n    try\n    {\n      window.top.name = toJson( loadData() );\n    }\n    catch (e)\n    {\n\n    }\n  }\n\n  return {\n\n    encode: function(key)\n    {\n      return this.prefix + toJson( key );\n    },\n\n    decode: function(rawKey)\n    {\n      return fromJson( rawKey.substring( this.prefix.length ) );\n    },\n\n    valid: function() \n    {\n      return window.top && typeof window.top.name !== 'undefined';\n    },\n\n    init: function(options, success, failure) \n    {\n      var promise = new Promise( this, success, failure );\n\n      this.prefix = coalesce( options.prefix, this.name + '-' );\n\n      promise.$bindTo( this.reload(), [this] );\n      \n      return promise;\n    },\n\n    reload: function(success, failure)\n    {\n      var promise = new Promise( this, success, failure );\n      var prefix = this.prefix;\n      var cache = new FastMap();\n      var data = loadData();\n\n      try\n      {\n        for (var rawKey in data)\n        {\n          if ( rawKey.substring( 0, prefix.length ) === prefix )\n          {\n            var rawValue = data[ rawKey ];\n            var value = fromJson( rawValue );\n            var key = this.decode( rawKey );\n\n            cache.put( rawKey, value, key );\n          }  \n        }\n\n        this.cache.overwrite( cache );\n        this.loaded = true;\n      }\n      catch (e)\n      {\n        promise.$failure( [e] );\n      }\n\n      this.finishReload( promise );\n\n      return promise;\n    },\n\n    _destroy: function(promise)\n    {\n      var keys = this.cache.keys;\n      var data = loadData();\n\n      for (var i = 0; i < keys.length; i++)\n      {\n        delete data[ keys[i] ];\n      }\n\n      this.cache.reset();\n\n      saveData();\n\n      promise.$success();\n    },\n\n    _put: function(key, value, rawKey, rawValue, promise)\n    {\n      var data = loadData();\n      var previousValue = this.cache.get( rawKey );\n\n      data[ rawKey ] = value;\n\n      this.cache.put( rawKey, value, key );\n\n      saveData();\n\n      promise.$success( [key, value, previousValue] );\n    },\n\n    _remove: function(key, rawKey, value, promise)\n    {\n      var data = loadData();\n\n      delete data[ rawKey ];\n\n      this.cache.remove( rawKey );\n\n      saveData();\n\n      promise.$success( [value, key] );\n    }\n\n  }\n});"],"sourceRoot":"/source/"}